#!/bin/bash 
# JustBOOT(tm) v0.3.0 - A Gentoo Linux LiveCD Generator.
##
# Copyright (C) 2009-2012 Mission Accomplish, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
###
VERSION=0.3.0
if [[ $1 =~ ^(--version|-[Vv])$ ]]; then echo "JustBOOT-${VERSION} see --help for more options"; exit 0; fi
if [ $(id -u) != 0 ]; then echo "This script must be run as root."; exit 1; fi

# Set some script variables before hand
NO_TOOL=false
YES_TOOL=false
LETMEIN=false
PURGE=false
PURGE_KERNEL=false
MENUCONFIG=false
DELETE_ARCH=false
VERBOSE=false
DEBUG=false

# Check for bash associated array support.
if ! declare -A &>/dev/null; then
  echo "This script uses bash4 only features, consider upgrading"
else
  BASH4=true
  declare -A PROCS=( [i386]=M386 [i486]=M486 [i586]=M586 [i686]=M686 [pentiumII]=MPENTIUMII [pentiumII]=MPENTIUMIII
[pentium-m]=MPENTIUMM [pentium4]=MPENTIUM4 [k6]=MK6 [k7]=MK7 [k8]=MK8 [opteron]=MK8 [core2]=MCORE2 [core2dou]=MCORE2 [generic]=GENERIC_CPU [x86_64]=GENERIC_CPU )
fi
declare -a LIVECD_EXCLUDES=( $(cat /etc/justboot/files/excluded-directories.lst | grep -vE '^#') )
declare -a REMOVE_PACKAGES=( $(cat /etc/justboot/files/remove-packages.lst | grep -vE '^#') )
declare -a REMOVE_FILES=( $(cat /etc/justboot/files/remove-files.lst | grep -vE '^#') )
declare -a RAMFS_DIR=( $(cat /etc/justboot/files/ramfs-directories.lst | grep -vE '^#') )
declare -a EXTRA_PACKAGES=( $(cat /etc/justboot/files/extra-packages.lst | grep -vE '^#') )
declare -a ARCHES=( x86_64 i386 i486 i586 i686 )
declare -a LOCALES=( $(cat /etc/justboot/locale.gen) )

# Set colors
BLUE="$(tput setaf 4)"
RED="$(tput setaf 1)"
NOCOLOR="$(tput setaf 9)"

einfo() { echo -e ".: ${1} :."; sleep 1; }
ewarn() { echo -e "\a${RED}.: ${1} :.${NOCOLOR}"; }
error() { echo -e "\a${RED}.: ${1} :.${NOCOLOR}"; exit 1; }

exec_chkdir() { local DIR="${1}"; [[ ! -d ${DIR} ]] && mkdir -p ${DIR}; }

exec_chklink() { 
  local SRC="${1}" DEST="${2}"
  [[ -h ${DEST} ]] && unlink ${DEST}
  ln -s ${SRC} ${DEST}
}

do_exec() {
  if ${DEBUG}; then
    echo -e "\a${RED}debug:${NOCOLOR}${BLUE} (${@})"${NOCOLOR}
    "${@}" 
  elif ${VERBOSE}; then
    "${@}" 
  else
    "${@}" 2>/dev/null 
  fi
}

# Help menu - TODO add moar examples!
print_help() {
cat << HELP
Usage: justboot [arguments] [make opts] [kernel opts]

Arguments:

--arch=	                - Set arch for livecd build i.e --arch=x86_64
--kernel=               - Kernel sources for livecd (Currently on zen-sources is supported)
--root-passwd=          - ROOT password for the livecd
--init-compression      - Currently only gzip and lzma compression is supported
--volid=		- Set a label for the livecd image.
--ramfs			- Compile in RAMFS "Must have ~4GB of available RAM"
--force-toolchain	- Force a rebuilt of the toolchain
--skip-toolchain	- Skips toolchain built for those in a hurry
--data-directory=	- Set the data directory for compiles
--package-manager=	- Enable the package manager for all builds. 
	Currently only pkgcore is supported, by default justboot uses portage
--letmein               - Will run /bin/bash at end of chroot stage for self maintanance
--verbose               - Run in verbose mode - lots of output
--purge                 - Purge old data and start fresh
--delete-arch		- Like --purge but exits script after
--debug                 - Turn on debugging

Gentoo make.conf options:

--cflags		- Compiler FLAGS
--ldflags=              - Linker FLAGS
--make-opts=            - MAKEOPTS 
--keywords=             - Accepted KEYWORDS i.e x86
--jobs=                 - Specifies the number of packages to build simultaneously
--use=                  - Packages USE flags
--features=             - make.conf specific FEATURES
--gentoo-mirrors=	- JustBOOT and make.conf space-seperated list of local mirrors
--rsync-mirror=		- Sets default rsync mirror
--niceness=		- make.conf specific PORTAGE_NICENESS

Linux Kernel options:

--coprocessor=		- Processor type for the livecd kernel i.e --coprocessor=core2
--coprocessor-list	- List the currently supported coprocessors
--menuconfig            - Runs make menuconfig for interactive kernel
--purge-kernel          - Purge any kernel sources and start fresh

Usage examples:
 Generate a 64bit livecd using gentoo-sources and set 'gentoo' for root password
# justboot --arch=x86_64 --kernel=gentoo-sources --root-passwd="gentoo"
 Generate a i686 livecd using zen-sources, with 'let me in!' as password with 'gentoo' for livecd label
# justboot --arch=i686 --kernel=zen-sources --volid="gentoo rocks" --root-passwd="let me in!"
 Generate a x86_64 livecd with optional gzip compression (Default is to use lzma)
# justboot --arch=x86_64 --init-compression lzma
 Generate a livecd but compile packages in ram
# justboot --arch=x86_64 -ramfs -L "Fast is good"
 Generate a livecd but delete old data directories first.
# justboot --arch=x86_64 --kernel=gentoo-sources --purge
 Generate a livecd for x86_64 using -j8 for makeopts and -19 for portage niceness
# justboot --arch=x86_64 --kernel=gentoo-sources --make-opts="-j8" --niceness="-19"
 Change the data directory for livecd creation
# justboot --arch=x86_64 --kernel=zen-sources --data-directory=/home/username
 Change the RSYNC and Gentoo Mirrors used for package downloads
# justboot --gentoo-mirrors="http://gentoo.mirrors.tera-byte.com/ http://mirror.datapipe.net/gentoo ftp://gentoo.chem.wisc.edu/gentoo/" --rsync-mirror="http://localhost/portage"
 Generater a livecd for a Opteron AMD processor
# justboot --coprocessor=opteron --arch=x86_64 --cflags="-march=opteron -Os -pipe" --make-opts=-j3
 Generater a livecd for a Intel Core2 Quad processor
# justboot --coprocessor=core2 --arch=core2 --cflags="-march=core2 -Os -pipe" --make-opts=-j5
 Generate x86_64 livecd with interactive kernel menu and custom rsync mirror
  justboot --arch=x86_64 --menuconfig --make-opts=-j5 --rsync-mirror=http://localhost/portage
# Use sys-apps/pkgcore for all livecd builds instead of portage
  justboot --arch=i486 --package-manager=pkgcore --root-passwd=letmein

HELP
exit 0
}

einfo "${BLUE}JustBOOT(tm)${NOCOLOR} initiated."

# Parse Command Line Arguments.
while [ $# -gt 0 ]; do
  case "$1" in
    --arch=*)
      ARCH="${1##*=}"
      einfo "${BLUE}${ARCH}${NOCOLOR} arch set"
      ;;
    --cflags=*) 
      ARG=$(echo ${1} | cut -d\= -f2-) # FIX ME
      CFLAGS=${ARG}
      einfo "CFLAGS set to ${BLUE}\"${CFLAGS}\""
      ;;
    --ldflags=*) LDFLAGS="${1##*=}";;
    --kernel=*)
      KERNEL_SOURCES="${1##*=}"
      einfo "${BLUE}${KERNEL_SOURCES} set"
      ;;
    --root-passwd=*)
      ROOT_PASSWD="${1##*=}"
      einfo "Setting ${RED}\"${ROOT_PASSWD}\"${NOCOLOR} as livecd root password"
      ;;
    --keywords=*)
      ACCEPT_KEYWORDS="${1##*=}"
      einfo "Setting ${BLUE}${ACCEPT_KEYWORDS}${NOCOLOR} for make.conf"
      ;;
    --ramfs|-ricer)
      RAMFS=true
      einfo "${RED}RAMFS${NOCOLOR} compiles enabled!!!"
      ;;
    --init-compression)
      INIT_COMPRESSION="${2}"
      einfo "Using ${BLUE}${INIT_COMPRESSION}${NOCOLOR} for initramfs compression"
      shift
      ;;
    --volid=*|-L)
      # We force underscore on Volume ID for compatibility.
      if [ ${1%%=*} = -L ]; then
        VOLID="${2// /_}"
        [ ${#VOLID} -gt 32 ] && error "${NOCOLOR}Volume label ${RED}\"${VOLID//_/ }\"${NOCOLOR} is greater than the 32 allowed characters"
        shift
      else
        ARG=${1##*=}
        VOLID="${ARG// /_}"
        [ ${#VOLID} -gt 32 ] && error "${NOCOLOR}Volume label ${RED}\"${VOLID//_/ }\"${NOCOLOR} is greater than the 32 allowed characters"
      fi
      einfo "Using ${RED}\"${VOLID//_/ }\"${NOCOLOR} for livecd label"
      ;;
    --data-directory=*)                 
      DIR="${1##*=}"                        
      LIVEDIR="${DIR/%\//}/justboot" # Remove leading slash
      einfo "Livecd data directory set to ${BLUE}\"${LIVEDIR}\"${NOCOLOR}"
      ;;
    --package-manager=*)
      [[ -f /etc/justboot/${ARCH}-pms ]] && error "Previously enabled package manager, delete /etc/justboot/${ARCH}-pms then try again to override"
      [[ ${1##*=} =~ ^(pkgcore|portage)$ ]] || { einfo "--package-manager=${RED}${1##*=}${NOCOLOR} is invalid, try pkgcore or portage"; error "Exiting!"; }
      if [[ ${1##*=} = portage ]]; then PMS="emerge -q"; else PMS="pmerge"; fi
      einfo "${RED}${PMS}${NOCOLOR} permanently enabled, to override delete /etc/justboot/${ARCH}-pms"
      echo ${PMS}>/etc/justboot/${ARCH}-pms # FIX/IMPROVE ME 
      ;; 
    --gentoo-mirrors=*)
      OPT="$(echo ${1##*=} | awk '{print$1}')"
      GENTOO_MIRROR="${OPT/%\/}" # Lets get rid of leading slash
      GENTOO_MIRRORS="${1##*=}"
      ;;
    --rsync-mirror=*) SYNC="${1##*=}";;
    --menuconfig) MENUCONFIG=true;;
    --force-toolchain) YES_TOOL=true;;
    --skip-toolchain) NO_TOOL=true;;
    --lang=*) LINGUAS="${1##*=}";;
    --niceness=*) PORTAGE_NICENESS="${1##*=}";;
    --use=*) USE="${1##*=}";;
    --make-opts=*) MAKEOPTS="${1##*=}";;
    --jobs=*) JOBS="${1##*=}";;
    --ldflags=*) LDFLAGS="${1##*=}";;
    --features=*) FEATURES="${1##*=}";;
    --letmein) LETMEIN=true;;
    --purge) PURGE=true;;
    --purge-kernel) PURGE_KERNEL=true;;
    --delete-arch) DELETE_ARCH=true;;
    --coprocessor=*) 
      CPU="${1##*=}"
      if [[ ${BASH4} && -z ${PROCS[${CPU}]} ]]; then
        ewarn "${CPU} is an invalid --coprocessor option."
        einfo "Available procs are: ${BLUE}i386,i486,i586,i686,k6,k7,k8,opteron,core2 & generic"
        ewarn "Exiting now."; exit 1
      fi
      ;;
    --coprocessor-list) einfo "Available procs are: ${BLUE}i386,i486,i586,i686,k6,k7,k8,opteron,core2 & generic"; exit 0;;
    --verbose) VERBOSE=true;;
    --debug|-db) DEBUG=true; einfo "Running in debug mode";;
    --help|-h) print_help;;
    *) error "${BLUE}Invalid argument ${RED}${1}!${NOCOLOR}, run \"$0 --help\" for help."
  esac
  shift
done

# Allow for user default $ARCH options i.e ~/.justboot/x86_64.conf
[[ -f ~/.justboot/${ARCH}.conf ]] && { exec_chkdir ~/.justboot; . ~/.justboot/${ARCH}.conf; }

# Check that we are using a valid $ARCH
for i in ${ARCHES[@]}; do 
  if [[ ${ARCH} != ${i} ]]; then
    INVALID_ARCH=true
  else
    INVALID_ARCH=false; break
  fi
done
${INVALID_ARCH} && { einfo "${RED}${ARCH}${NOCOLOR} is invalid, valid options are ${ARCHES[@]}"; error "Exiting!!!"; }

# Convert ARCH value for /etc/make.conf 
case ${ARCH} in
  x86_64) MAKE_ARCH=x86-64; [[ ${ACCEPT_KEYWORDS} ]] || MAKE_KEYWORDS="~x86 ~amd64";;
  i[4,5,6]86) [[ ${ACCEPT_KEYWORDS} ]] || MAKE_KEYWORDS="~x86"
esac

# Source JustBOOT global configuration options
. /etc/justboot/config.globals

# When no --data-directory is set we default to /usr/share/justboot, but we check for existing symbolic link
# so our $LIVEDIR always points to the correct arch sources
if [[ -h /usr/share/justboot/${ARCH} ]]; then
  LINK=$(readlink /usr/share/justboot/${ARCH})
  LIVEDIR=${LINK/\/${ARCH}/}
  DATA_DIR=${LIVEDIR}/data
  ARCH_DIR=${LIVEDIR}/${ARCH}
  EXCLUDES_DIR=${LIVEDIR}/excludes/${ARCH}
fi

# Check if we previously set a package manager for compiles on ${ARCH}
if [[ ! -f /etc/justboot/${ARCH}-pms ]]; then PMS="emerge -q"; else PMS="$(cat /etc/justboot/${ARCH}-pms)"; fi

# Remove old data directories (--purge/--delete-arch)
if ${PURGE} || ${DELETE_ARCH}; then
  src=$(readlink /usr/share/justboot/${ARCH})
  einfo "${RED}--purge or --delete-arch flag used.${NOCOLOR} Removing ${RED}${ARCH}${NOCOLOR} sources."
  if [[ -h /usr/share/justboot/${ARCH} ]]; then
    do_exec rm -rf $(readlink /usr/share/justboot/excludes/${ARCH})
    do_exec rm -rf $(readlink /usr/share/justboot/${ARCH})
      for i in /usr/share/justboot/excludes/${ARCH} /usr/share/justboot/${ARCH}; do
        do_exec unlink ${i}
      done
  elif [[ -d /usr/share/justboot/${ARCH} ]]; then
    do_exec rm -rf /usr/share/justboot/${ARCH} /usr/share/justboot/excludes/${ARCH}
  else
    einfo "No ARCH to purge or remove! Exiting"; exit 1
  fi
  for i in i{4,5,6}86 x86_64; do
    [[ ${i} = ${ARCH} ]] && continue 2
    [[ -d ${src/${ARCH}/${i}} ]] && { REMOVAL=true; break; }
  done
  if ! ${REMOVAL}; then
    ewarn "Removing orphan data directory ${RED}${src/\/${ARCH}}"
    do_exec unlink ${src/\/${ARCH}//data} 
    do_exec rm -rf ${src/\/${ARCH}}
  fi
  ${DELETE_ARCH} && { einfo "All done ${ARCH} sources removed, exiting"; exit 0; }
fi

# The stage in which we umount all livecd data and copy any --ramfs changes to the excluded directories
# First we remove local livecd folders i.e proc,dev and the data directory, then we copy any ramfs changes to
# the livecd exclude folders. See the /etc/justboot/files/{ramfs-directories,excluded-directories}.lst file 
release_env() {            
  einfo "Releasing livecd environment, please wait..."
  do_exec rm -rf ${ARCH}/tmp/* 
  do_exec umount ${ARCH_DIR}/{proc,dev} ${ARCH}${DATA_DIR} 
                           
  if [ ${RAMFS} ]; then    
    for x in "${LIVECD_EXCLUDES[@]}"; do
      for y in "${RAMFS_DIR[@]}"; do
        if [[ ${x} = ${y} ]]; then
          einfo "Removing ${RED}${x}${NOCOLOR} from memory.. please wait"
          do_exec rsync -caq --delete-before ${ARCH}/${x}/* ${EXCLUDES_DIR}/${x//\//:} &>/dev/null
          do_exec umount ${ARCH}/${x} 1>/dev/null 
          einfo "Copied ${BLUE}${x}${NOCOLOR} changes to ${RED}${EXCLUDES_DIR}/${x//\//:}${NOCOLOR}"
          continue 2
        fi
      done                 
      do_exec umount ${ARCH}/${x} 1>/dev/null
    done
                           
    for x in "${RAMFS_DIR[@]}"; do
      for y in "${LIVECD_EXCLUDES[@]}"; do
        [[ ${x} = ${y} ]] && continue 2
      done                 
      einfo "Removing ${RED}${x}${NOCOLOR} from memory.. please wait."
      do_exec rsync -caq --delete-before ${ARCH}/${x}/* ${EXCLUDES_DIR}/${x//\//:} &>/dev/null
      do_exec umount ${ARCH}/${x} 1>/dev/null
      einfo "Copied ${BLUE}${x}${NOCOLOR} changes to ${RED}${EXCLUDES_DIR}/${x//\//:}"
    done
  else  
    for x in "${LIVECD_EXCLUDES[@]}"; do
      do_exec umount ${ARCH}/${x} 1>/dev/null
    done
  fi
  [ ! $1 ] && do_exec clean_env
}

USER_INTERRUPT=13
trap 'release_env now; exit $USER_INTERRUPT' TERM INT
#  Cleans up the livecd environment if script is interrupted by Control-C.

# Check local system for requires packages.
check_deps() {
  if [[ ${PMS} = pmerge ]]; then
    if ! hash pmerge &>/dev/null; then
      einfo "Compiling sys-apps/pkgcore."
      do_exec emerge pkgcore 1>/dev/null
    fi
  fi

  if ! hash mksquashfs &>/dev/null; then
    einfo "Compiling ${BLUE}squashfs-tools."
    do_exec ${PMS} squashfs-tools 1>/dev/null
  fi
}

# Preparation of the stage1 build - we skip most of this and only run through half of it once
# unless we are starting fresh or ran justboot with --purge argument.
prepare_stage() {
  if [[ ! -d ${ARCH_DIR} || ${LIVEDIR} = /usr/share/justboot ]]; then
    if [[ -h /usr/share/justboot/${ARCH} ]]; then
      local REAL_ARCH_DIR=$(readlink /usr/share/justboot/${ARCH})
      local REAL_EXCLUDES_DIR=$(readlink /usr/share/justboot/excludes/${ARCH})

      einfo "Moving data directory from ${RED}${REAL_ARCH_DIR}${NOCOLOR} to ${RED}${LIVEDIR}/${ARCH}..${NOCOLOR} please wait..."
      for i in /usr/share/justboot/${ARCH} /usr/share/justboot/excludes/${ARCH}; do
        do_exec unlink ${i} 
      done

      exec_chkdir ${LIVEDIR}/excludes
      do_exec mv ${REAL_ARCH_DIR} ${ARCH_DIR}
      do_exec mv ${REAL_EXCLUDES_DIR} ${EXCLUDES_DIR}
      
      if [[ ${LIVEDIR} != /usr/share/justboot ]]; then
        exec_chklink ${ARCH_DIR} /usr/share/justboot/${ARCH}
        exec_chklink ${LIVEDIR}/excludes/${ARCH} /usr/share/justboot/excludes/${ARCH}
        exec_chklink /usr/share/justboot/data ${DATA_DIR}
      fi

      for i in i{4,5,6}86 x86_64; do
        [[ ${i} = ${ARCH} ]] && continue 2
        [[ -d ${REAL_ARCH_DIR/${ARCH}/${i}} ]] && { REMOVAL=true; break; }
      done
      if ${REMOVAL}; then
        ewarn "Removing old data directory ${RED}${REAL_ARCH_DIR}"
        do_exec rm -rf ${REAL_ARCH_DIR} ${REAL_EXCLUDES_DIR} 
      else
        ewarn "Removing old data directory ${RED}${REAL_ARCH_DIR/\/${ARCH}}"
        do_exec unlink ${REAL_ARCH_DIR/\/${ARCH}//data}
        do_exec rm -rf ${REAL_ARCH_DIR/\/${ARCH}/}
      fi        
  elif [[ /usr/share/justboot != ${LIVEDIR} && -d /usr/share/justboot/${ARCH} ]]; then 
      einfo "Moving data directory from ${RED}/usr/share/justboot/${ARCH}${NOCOLOR} to ${RED}${LIVEDIR}/${ARCH}.${NOCOLOR} please wait..."

      exec_chkdir ${LIVEDIR}/excludes
      do_exec mv /usr/share/justboot/${ARCH} ${ARCH_DIR}
      do_exec mv /usr/share/justboot/excludes/${ARCH} ${EXCLUDES_DIR}

      exec_chklink ${ARCH_DIR} /usr/share/justboot/${ARCH}
      exec_chklink ${LIVEDIR}/excludes/${ARCH} /usr/share/justboot/excludes/${ARCH}
      exec_chklink /usr/share/justboot/data ${DATA_DIR}
    fi
  fi  
 
  # Convert x86_64 arch for proper usage in Gentoo.
  case ${ARCH} in
    x86_64) local GENTOO_ARCH=amd64 STAGE=amd64;;
    i[4,5,6]86)
      if [[ ${ARCH} = i586 ]]; then
        local STAGE=i486
        local GENTOO_ARCH=x86
      else
        local STAGE=${ARCH}
        local GENTOO_ARCH=x86
      fi
  esac

  if [[ ! -d ${ARCH_DIR} ]]; then
    einfo "Building initial stage1 for ${BLUE}${GENTOO_ARCH}${NOCOLOR}. please wait..."

    do_exec wget -q ${GENTOO_MIRROR}/releases/${GENTOO_ARCH}/current
    local GENTOO_STAGE=$(egrep -o stage3-${STAGE}-[[:digit:]]{8}.tar.bz2 index.html | uniq)
    do_exec rm index.html

    exec_chkdir ${ARCH_DIR}
    do_exec cd ${ARCH_DIR} || error "Failed to switch to ${ARCH_DIR}"

    einfo "Fetching gentoo ${GENTOO_STAGE} autobuild stage"
    do_exec wget -q ${GENTOO_MIRROR}/releases/${GENTOO_ARCH}/current/${GENTOO_STAGE}

    einfo "Extracting ${GENTOO_STAGE}"
    do_exec tar xjpf ${GENTOO_STAGE} 
    do_exec rm ${GENTOO_STAGE}

    einfo "Fetching portage tree snapshot"
    do_exec wget -q ${GENTOO_MIRROR}/snapshots/portage-latest.tar.bz2

    einfo "Extracting portage-latest.tar.bz2"
    do_exec tar xjpf portage-latest.tar.bz2 -C usr/ 
    do_exec rm portage-latest.tar.bz2

    exec_chkdir ${EXCLUDES_DIR} 
    exec_chkdir /usr/share/justboot/excludes

    for i in "${LIVECD_EXCLUDES[@]}"; do
      exec_chkdir ${EXCLUDES_DIR}/${i//\//:}
      do_exec mv ${i}/* ${EXCLUDES_DIR}/${i//\//:} &>/dev/null
    done

    einfo "Done with stage1 for ${BLUE}${GENTOO_ARCH}.${NOCOLOR}"

    if [[ ${LIVEDIR} != /usr/share/justboot ]]; then
      exec_chklink ${ARCH_DIR} /usr/share/justboot/${ARCH}
      exec_chklink ${LIVEDIR}/excludes/${ARCH} /usr/share/justboot/excludes/${ARCH}
      exec_chklink /usr/share/justboot/data ${DATA_DIR}
    fi
  fi
  prepare_env
}

# After we have prepared the stage1 build, we need to detect/setup all the livecd exclude directories and or ramfs mounts first
# before we start the chroot process and compile packages
prepare_env() {
  cd ${LIVEDIR}
  exec_chkdir ${ARCH_DIR}${DATA_DIR}
  exec_chkdir ${ARCH_DIR}/mnt/gentoo

  do_exec mount -o bind /proc ${ARCH}/proc
  do_exec mount -o bind /dev ${ARCH}/dev 
  do_exec mount -o bind ${DATA_DIR} ${ARCH}${DATA_DIR} 

  for x in "${LIVECD_EXCLUDES[@]}"; do
    if [[ $(ls ${ARCH}/${x//://} 2>/dev/null | grep -v .keep | wc -l) != 0 ]]; then
      einfo "Detected newly added ${BLUE}${x}${NOCOLOR} for livecd excludes, moving data to ${RED}${EXCLUDES_DIR}/${x//\//:}.${NOCOLOR} please wait..."
      exec_chkdir ${EXCLUDES_DIR}/${x//\//:}
      do_exec mv ${ARCH}/${x}/* ${EXCLUDES_DIR}/${x//\//:} &>/dev/null
      do_exec rm -rf ${ARCH}/${x}/* 
    fi
  done

  if [ ${RAMFS} ]; then
    for x in "${LIVECD_EXCLUDES[@]}"; do
      for y in "${RAMFS_DIR[@]}"; do
        if [[ ${x} = ${y} ]]; then
          einfo "Mounting ${BLUE}${x}${NOCOLOR} in memory.. please wait"
          do_exec mount -t ramfs ${x} ${ARCH}/${x} 1>/dev/null 

          [[ ! -d ${EXCLUDES_DIR}/${x//\//:} ]] && exec_chkdir ${EXCLUDES_DIR}/${x//\//:}
          do_exec rsync -caq ${EXCLUDES_DIR}/${x//\//:}/* ${ARCH}/${x} &>/dev/null

          einfo "${RED}${x}${NOCOLOR} copied to RAMFS" 
          continue 2
        fi
      done
      do_exec mount -o bind ${EXCLUDES_DIR}/${x//\//:} ${ARCH}/${x} 1>/dev/null 
    done

    for x in "${RAMFS_DIR[@]}"; do
      for y in "${LIVECD_EXCLUDES[@]}"; do
        [[ ${x} = ${y} ]] && continue 2
      done
      einfo "Mounting ${BLUE}${x}${NOCOLOR} in memory.. please wait."

      if [[ $(ls ${ARCH}/${x} 2>/dev/null | grep -v .keep | wc -l) != 0 ]]; then
        exec_chkdir ${EXCLUDES_DIR}/${x//\//:}
        einfo "${BLUE}${ARCH}/${x}${NOCOLOR} is not empty, moving data to ${RED}${EXCLUDES_DIR}/${x//\//:}.${NOCOLOR} please wait..."
        do_exec mv ${ARCH}/${x}/* ${EXCLUDES_DIR}/${x//\//:} &>/dev/null
      else
        for i in ${ARCH}/${x} ${EXCLUDES_DIR}/${x//\//:}; do exec_chkdir ${i}; done
      fi
      do_exec mount -t ramfs ${x} ${ARCH}/${x} 1>/dev/null

      if [[ -d ${EXCLUDES_DIR}/${x//\//:} ]]; then
        do_exec rsync -caq ${EXCLUDES_DIR}/${x//\//:}/* ${ARCH}/${x} &>/dev/null
        einfo "${RED}${x}${NOCOLOR} copied to RAMFS"
      fi
    done

    declare -a DIRS
    ( 
    cd ${EXCLUDES_DIR}
    DIRS=( * )
    for y in "${DIRS[@]}"; do
      for z in "${LIVECD_EXCLUDES[@]}" "${RAMFS_DIR[@]}"; do
        [[ ${y} = ${z//\//:} ]] && continue 2
      done
      einfo "${BLUE}${y}${NOCOLOR} is an orphan directory."
      einfo "Moving data to ${RED}${ARCH}/${y//://}.${NOCOLOR} please wait..."
      do_exec mv ${EXCLUDES_DIR}/${y}/* ${ARCH}/${y//://} &>/dev/null
      do_exec rm -rf ${EXCLUDES_DIR}/${y}
    done
    )
  else
    declare -a DIRS
    ( 
    cd ${EXCLUDES_DIR}
    DIRS=( * )
    for y in "${DIRS[@]}"; do
      for z in "${LIVECD_EXCLUDES[@]}"; do
        [[ ${y} = ${z//\//:} ]] && continue 2
      done
      einfo "${BLUE}${y}${NOCOLOR} is either an orphan directory or part of an old ${BLUE}ramfs (--ramfs)${NOCOLOR} run."
      einfo "Moving data to ${RED}${ARCH}/${y//://}.${NOCOLOR} please wait..."
      do_exec mv ${EXCLUDES_DIR}/${y}/* ${ARCH}/${y//://} &>/dev/null
      do_exec rm -rf ${EXCLUDES_DIR}/${y}
    done
    )
    einfo "Mounting livecd data files"
    for x in "${LIVECD_EXCLUDES[@]}"; do
      do_exec mount -o bind ${EXCLUDES_DIR}/${x//\//:} ${ARCH}/${x} 1>/dev/null
    done
  fi

  [[ ! -d ${ARCH_DIR}/mnt/livecd ]] && do_exec mkdir -p ${ARCH_DIR}/mnt/livecd/{static,image,dynamic}
  
  einfo "Entering the livecd chroot environment."
  do_exec chmod +x ${CHROOT_SCRIPT} && do_exec mv ${CHROOT_SCRIPT} ${ARCH_DIR}/tmp
  do_exec cp /etc/resolv.conf ${ARCH_DIR}/etc
  
  if [[ ${ARCH} =~ ^i[4-6]86$ ]]; then
    do_exec linux32 chroot ${ARCH_DIR} ${CHROOT_SCRIPT} && do_exec rm ${ARCH_DIR}${CHROOT_SCRIPT}
  else
    do_exec linux64 chroot ${ARCH_DIR} ${CHROOT_SCRIPT} && do_exec rm ${ARCH_DIR}${CHROOT_SCRIPT}
  fi

  [[ $? = 13 ]] && do_exec release_env now

  einfo "Exiting livecd chroot environment."
  do_exec env-update 1>/dev/null && do_exec source /etc/profile
  do_exec release_env 
}

# Before we create our iso image we will clean up the environment of any excluded packages and common directories or files that
# we don't require for livecd operations
clean_env() {
  local TARGET=${LIVEDIR}/target/files/${ARCH}
  local CLEANUP_SCRIPT=$(mktemp /tmp/XXX)

  [[ -d ${LIVEDIR}/target ]] && do_exec rm -rf ${LIVEDIR}/{boot,target}
  exec_chkdir ${TARGET}

  einfo "Performing livecd cleanup, please wait..."
  do_exec cp -a ${ARCH_DIR}/* ${LIVEDIR}/target/files/${ARCH} &>/dev/null

  if [[ -d ${EXCLUDES_DIR}/boot ]]; then
    do_exec cp -a ${EXCLUDES_DIR}/boot ${LIVEDIR}/target 
    do_exec cp -a ${EXCLUDES_DIR}/boot ${LIVEDIR} 
  else
    do_exec cp -a ${ARCH_DIR}/boot ${LIVEDIR}/target 
    do_exec cp -a ${ARCH_DIR}/boot ${LIVEDIR} 
  fi

  for i in "${LIVECD_EXCLUDES[@]}"; do
    if [[ $(ls ${EXCLUDES_DIR}/${i//\//:} 2>/dev/null | grep -v .keep | wc -l) != 0 ]]; then
      einfo "Moving ${BLUE}${i}${NOCOLOR} to ${RED}${TARGET}/${i}.${NOCOLOR} please wait..."
      do_exec cp -a ${EXCLUDES_DIR}/${i//\//:}/* ${TARGET}/${i} &>/dev/null  
    fi
  done

  if [ ${RAMFS} ]; then
    for x in "${RAMFS_DIR[@]}"; do
      for y in "${LIVECD_EXCLUDES[@]}"; do
        [[ ${x} = ${y} ]] && continue 2
      done
        if [[ $(ls ${EXCLUDES_DIR}/${x//\//:} 2>/dev/null | grep -v .keep | wc -l) != 0 ]]; then
          einfo "Moving ${BLUE}${x}${NOCOLOR} to ${RED}${TARGET}/${x}.${NOCOLOR} please wait..."
          do_exec cp -a ${EXCLUDES_DIR}/${x//\//:}/* ${TARGET}/${x} &>/dev/null
        fi
    done
  fi

cat >> ${CLEANUP_SCRIPT} << CLEANUP
#!/bin/bash
  trap 'echo "User interrupted, Exiting"; exit $USER_INTERRUPT' TERM INT
  #  Cleans up the environment if script interrupted by control-c.

  echo "Entering livecd environment"
  env-update 1>/dev/null && source /etc/profile

  for i in ${REMOVE_PACKAGES[@]}; do
    echo "Removing \${i} from livecd"
    ${PMS} -C \${i} &>/dev/null
  done

  echo -e "${RED}${#REMOVE_PACKAGES[@]}${NOCOLOR} Packages removed."
  exit
CLEANUP
  do_exec chmod +x ${CLEANUP_SCRIPT} && do_exec mv ${CLEANUP_SCRIPT} ${TARGET}/tmp

  if [[ ${ARCH} =~ ^i[4-6]86$ ]]; then
    do_exec linux32 chroot ${TARGET} ${CLEANUP_SCRIPT} 
  else
    do_exec linux64 chroot ${TARGET} ${CLEANUP_SCRIPT}
  fi

  [[ $? = 13 ]] && do_exec release_env now

  do_exec cd ${TARGET}
  do_exec rm -rf ${REMOVE_FILES[@]} ${LIVECD_EXCLUDES[@]}

  for i in boot var/run/dbus var/lock/subsys var/cache/edb/deb var/cache/hald var/log root var/log; do
    do_exec exec_chkdir ${i}
  done

  # Create mtab file
  >etc/mtab

  do_exec create_livecd
}

# Livecd creation function
create_livecd() {
  local DATE=$(date +%m%d%Y-%H%M)
  do_exec touch ${LIVEDIR}/target/livecd

  einfo "Building SquashFS."
  do_exec mksquashfs ${LIVEDIR}/target/files/${ARCH}/ ${LIVEDIR}/target/livecd.squashfs
  einfo "Generating bootable JustBOOT(tm) livecd image."
  do_exec mkisofs -volid \"${VOLID}\" -R -b boot/grub/stage2_eltorito -no-emul-boot -boot-load-size 4 -boot-info-table \
-iso-level 4 -hide-rr-moved -c boot.catalog -o ${LIVEDIR}/${ARCH}-${KERNEL_SOURCES}-${DATE}.iso -x files ${LIVEDIR}/target/
  
  do_exec rm -rf ${LIVEDIR}/{target,boot}
  einfo "All Done. ${ARCH} livecd located at ${LIVEDIR}/${ARCH}-${KERNEL_SOURCES}-${DATE}.iso"
}

cat >> ${CHROOT_SCRIPT} << CHROOT
#!/bin/bash
ARCH=${ARCH}
UCLIBC="${DATA_DIR}/uclibc"
UCLIBC_SCRIPT=\$(mktemp /tmp/XXX)
UCLIBC_SRC_URI="http://gentoo.mirrors.tds.net/gentoo/experimental/x86/embedded/stages/stage3-x86-uclibc-2008.0.tar.bz2"
BUSYBOX_SRC_URI="http://www.busybox.net/downloads/busybox-1.14.0.tar.gz"
BUSYBOX_ARCHIVE=\$(echo \${BUSYBOX_SRC_URI} | egrep -o 'busybox-[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.tar\.gz')
BUSYBOX_CONF=${DATA_DIR}/busybox/.config
BUSYBOX=\${BUSYBOX_ARCHIVE/.tar.gz/}
BLUE="\$(tput setaf 4)"
RED="\$(tput setaf 1)"
NOCOLOR="\$(tput setaf 9)"

trap 'echo "User interrupted, Exiting"; exit $USER_INTERRUPT' TERM INT
#  Cleans up the environment if script interrupted by control-c.

env-update 1>/dev/null && source /etc/profile

einfo() { echo -e ".: \${1} :."; sleep 1; }
ewarn() { echo -e "\a\${RED}.: \${1} :.\${NOCOLOR}"; }
error() { echo -e "\a\${RED}.: \${1} :.\${NOCOLOR}"; exit 1; }

exec_chklink() {
  local SRC="\${1}" DEST="\${2}"
  [[ -h \${DEST} ]] && unlink \${DEST}
  ln -s \${SRC} \${DEST}
}
 
do_exec() {
  if ${DEBUG}; then
    echo -e "\a\${RED}debug:\${NOCOLOR}\${BLUE} (\${@})"\${NOCOLOR}
    "\${@}"
  elif ${VERBOSE}; then
    "\${@}"
  else
    "\${@}" 2>/dev/null
  fi
}

check_deps() {
  # Check for pkgcore if --package-manager=pkgcore is used"
  if [[ "${PMS}" = pmerge ]]; then   
    if ! hash pmerge &>/dev/null; then
      einfo "Compiling sys-apps/pkgcore."
      do_exec emerge pkgcore 1>/dev/null
    fi
  fi
} 

prepare_configs() {
  do_exec cp -a ${DATA_DIR}/etc/fstab /etc
  do_exec cp -a ${DATA_DIR}/etc/portage /etc
  do_exec cp -a ${DATA_DIR}/etc/conf.d/{hostname,net,clock} /etc/conf.d

  if [[ ! \$(grep JustBOOT /etc/make.conf 2>/dev/null) ]]; then
    >/etc/make.conf
# Generate our make.conf if this is a new livecd build.
cat >> /etc/make.conf << MAKECONF
# /etc/make.conf generated by the JustBOOT(tm) livecd generator
#
CFLAGS="${CFLAGS}"
CHOST="${CHOST}"
CXXFLAGS="${CFLAGS}"
MAKEOPTS="${MAKEOPTS}"
LDFLAGS="${LDFLAGS}"
USE="${USE}"
LINGUAS="${LINGUAS}"
FEATURES="${FEATURES}"
PORTAGE_NICENESS="${PORTAGE_NICENESS}"
ACCEPT_KEYWORDS="${ACCEPT_KEYWORDS}"
PORT_LOGDIR=/var/log/portage
SYNC="${SYNC}"
GENTOO_MIRRORS="${GENTOO_MIRRORS}"
CLEAN_DELAY="1"
EMERGE_WARNING_DELAY="1"
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS}"
MAKECONF
  fi
}
  
# Prepare the livecd required and user packages.
prepare_packages() {
  local -a GLOBAL_PACKAGES=( 'grub:sys-boot/grub' 'net-setup:app-misc/livecd-tools' 'lshw:sys-apps/lshw' 'mkfs.reiser4:sys-fs/reiser4progs' \
'mkfs.jfs:sys-fs/jfsutils' 'mkfs.xfs:sys-fs/xfsprogs' 'mkfs.reiserfs:sys-fs/reiserfsprogs' 'mdadm:sys-fs/mdadm' 'screen:app-misc/screen' \
'rsync:net-misc/rsync' 'dhcpcd:net-misc/dhcpcd' 'ntpd:net-misc/openntpd' 'sudo:app-admin/sudo' )

  for i in \${GLOBAL_PACKAGES[@]}; do
    if ! hash \${i/:*/} &>/dev/null; then
      einfo "Compiling \${BLUE}\${i/*:/}."
      do_exec ${PMS} \${i/*:/} 1>/dev/null
    fi
  done

  for i in ${EXTRA_PACKAGES=[@]}; do
    if ! hash \${i/:*/} &>/dev/null; then
      einfo "Compiling \${BLUE}\${i}."
      do_exec ${PMS} \${i/*:/} 1>/dev/null
    fi 
  done

  if ! hash memtest86+ &>/dev/null; then do_exec ${PMS} memtest86+ 1>/dev/null; fi
  # Setup sudoers
  [ -f /etc/sudoers ] && sed -i '/NOPASSWD: ALL/ s/^# //' /etc/sudoers
}

prepare_bootloader() {
  [[ -h /boot/grub/menu.lst ]] && do_exec unlink /boot/grub/menu.lst

  # Always a fresh grub.conf, eventually it will parse for changes then update.
  >/boot/grub/menu.lst
cat >> /boot/grub/menu.lst << GRUB
default 0
timeout 3
splashimage=/boot/grub/splash.xpm.gz

title=JustBOOT
        kernel /boot/vmlinuz root=/dev/loop0 vga=ask
        initrd /boot/${ARCH}-initramfs_data.cpio.lzma
title=JustBOOT NO-FB
        kernel /boot/vmlinuz root=/dev/loop0
        initrd /boot/${ARCH}-initramfs_data.cpio.lzma
title=Memtest86+
        kernel /boot/memtest86plus/memtest.bin
GRUB
  do_exec cp /boot/grub/menu.lst /boot/grub/grub.conf
}

prepare_busybox() {
  if [[ ! -d \${UCLIBC} ]]; then
    do_exec mkdir -p \${UCLIBC}
    do_exec cd \${UCLIBC}

    einfo "Fetching Gentoo UCLIBC stage3 tarball"
    do_exec wget -q \${UCLIBC_SRC_URI}
    
    einfo "Extracting Gentoo UCLIBC stage3 tarball"
    do_exec tar xjpf stage*

    einfo "Fetching Busybox sources"
    do_exec wget -q \${BUSYBOX_SRC_URI}
    
    einfo "Extracting Busybox sources"
    do_exec tar zxf \${BUSYBOX_ARCHIVE}
  fi

  do_exec cp -a ${DATA_DIR}/busybox/.config \${UCLIBC}/\${BUSYBOX}

  einfo "Entering UCLIBC environment"
  do_exec chmod +x \${UCLIBC_SCRIPT} && do_exec mv \${UCLIBC_SCRIPT} \${UCLIBC}/tmp

  do_exec linux32 chroot \${UCLIBC} \${UCLIBC_SCRIPT}

  einfo "Done with busybox build"
}

# The setup of our initramfs image
prepare_initramfs() {
  local INITRAMFS_DIR=/tmp/initramfs
  KERNEL_SRC=\$(readlink /usr/src/linux)
  KERNEL_MODULE_SRC=\$(echo \${KERNEL_SRC} | cut -d- -f2-)

  [[ -d \${INITRAMFS_DIR} ]] && do_exec rm -rf \${INITRAMFS_DIR}
  do_exec mkdir \${INITRAMFS_DIR} && do_exec cd \${UCLIBC}/\${BUSYBOX}
  ./applets/install.sh \${INITRAMFS_DIR} --symlinks 1>/dev/null

  do_exec cd \${INITRAMFS_DIR}
  do_exec mkdir -p proc sys dev mnt new-root lib mnt/livecd mnt/livecd/{static,dynamic,image} lib/modules
  do_exec cp -a ${DATA_DIR}/initramfs/etc .

  do_exec cp ${DATA_DIR}/initramfs/init .
  do_exec chmod 755 init
  do_exec mknod dev/console c 5 1
  do_exec mknod dev/null c 1 3
  do_exec mknod dev/tty1 c 4 1

  do_exec cp -a /lib/modules/\${KERNEL_MODULE_SRC} lib/modules/

  [[ -f /boot/${ARCH}-initramfs_data.cpio.${INIT_COMPRESSION} ]] && do_exec rm /boot/${ARCH}-initramfs_data.cpio.${INIT_COMPRESSION}
  find | cpio --quiet -o -H newc | ${INIT_COMPRESSION} -9 >/boot/${ARCH}-initramfs_data.cpio.${INIT_COMPRESSION}
}

# This function handles the custom kernel options with --coprocessor argument
prepare_kernel_opts() {
  ( # Spawn a new shell to avoid leaving current working path
  cd ${DATA_DIR}/kernel/\${1} || error "Could not switch to kernel source directory"
  case ${ARCH} in
    i[4,5,6]86)
      if [[ ${PROCS[${CPU}]} != M486 ]]; then
        sed -e 's/CONFIG_M486=y/# CONFIG_M486 is not set/' -e "s/# CONFIG_${PROCS[${CPU}]} is not set/CONFIG_${PROCS[${CPU}]}=y/" ${KERNEL_SOURCES} >${KERNEL_SOURCES}-custom
      fi
      [[ ${ARCH} = i586 || ${PROCS[${CPU}]} = M586 ]] && patch -sp0 <${KERNEL_SOURCES}-i586-config.patch
      [[ ${ARCH} = i686 || ${PROCS[${CPU}]} = M686 ]] && patch -sp0 <${KERNEL_SOURCES}-i686-config.patch
      case ${PROCS[${CPU}]} in                                        
        MK8) patch -p0 <${KERNEL_SOURCES}-x86-k8_proc.config.patch;;
        MCORE2) patch -p0 <${KERNEL_SOURCES}-x86-core2_proc.config.patch
      esac
      ;;
    x86_64)
      if [[ ${PROCS[${CPU}]} != GENERIC_CPU ]]; then                                                                
      sed -e 's/CONFIG_GENERIC_CPU=y/# CONFIG_GENERIC_CPU is not set/' -e "s/# CONFIG_${PROCS[${CPU}]} is not set/CONFIG_${PROCS[${CPU}]}=y/" ${KERNEL_SOURCES} >${KERNEL_SOURCES}-custom
      fi
  esac                                                                   
  if [[ ${PROCS[${CPU}]} =~ ^(M486|GENERIC_CPU)$ ]]; then do_exec cp ${KERNEL_SOURCES} /usr/src/linux/.config; else do_exec cp ${KERNEL_SOURCES}-custom /usr/src/linux/.config; fi
  )
}

# JustBOOT kernel compilation and customization options
prepare_kernel() {
  local DATE=$(date +%Y%m%d-%H%m)

  if ${PURGE_KERNEL}; then
    ewarn "--purge-kernel used,.. removing sources."
    do_exec unlink /usr/src/linux
    do_exec rm -rf /usr/src/* /lib/modules/*
  fi

  # Convert x86 arch for proper usage in kernel
  case ${ARCH} in i[4,5,6]86) local ARCH=x86;; esac

  if [[ ! -h /usr/src/linux || ! \$(ls -d /var/db/pkg/sys-kernel/${KERNEL_SOURCES}-[0-9]* 2>/dev/null) ]]; then
    if ! ls -d /var/db/pkg/app-portage/layman-[0-9]* &>/dev/null; then
      einfo "Compiling \${BLUE}layman"
      do_exec ${PMS} layman # 1>/dev/null
    fi
 
    if [[ ${KERNEL_SOURCES} = zen-sources ]]; then
      do_exec layman -Sa zen-overlay 1>/dev/null && echo "source /usr/local/portage/layman/make.conf">>/etc/make.conf
    fi
  
    einfo "Compiling \${BLUE}${KERNEL_SOURCES}"
    if [[ ! \$(grep "sys-kernel/${KERNEL_SOURCES} symlink" /etc/portage/package.use 2>/dev/null) ]]; then 
      echo "sys-kernel/${KERNEL_SOURCES} symlink">>/etc/portage/package.use
    fi
    # Bug with pkgcore and zen-sources
    if [ ${PMS} = pmerge ]; then do_exec emerge ${KERNEL_SOURCES} 1>/dev/null; else do_exec ${PMS} ${KERNEL_SOURCES} 1>/dev/null; fi

    einfo "Compiling \${BLUE}\${ARCH}\${NOCOLOR} kernel image"
    if declare -A &>/dev/null; then
      prepare_kernel_opts \${ARCH}
    else
      do_exec cp ${DATA_DIR}/kernel/${ARCH}/${KERNEL_SOURCES} /usr/src/linux/.config
    fi
      
    do_exec cd /usr/src/linux || error "Failed to switch to kernel source directory"

    if ${MENUCONFIG}; then
      do_exec make menuconfig
      do_exec make ${MAKEOPTS} 1>/dev/null
    else
      do_exec make ${MAKEOPTS} 1>/dev/null
    fi

    do_exec make modules_install 1>/dev/null
    einfo "\${RED}\${ARCH}\${NOCOLOR} kernel compiled, preparing initramfs image."
    do_exec prepare_initramfs
  else
    if [[ -f /usr/src/linux/.config ]]; then
      einfo "Backing up old kernel config to \${RED}/usr/src/linux/.config.\${DATE}\${NOCOLOR}"
      do_exec cp /usr/src/linux/.config /usr/src/linux/.config.${KERNEL_SOURCES}-\${DATE}
    fi

    einfo "Compiling \${RED}\${ARCH}\${NOCOLOR} kernel image."
    if declare -A &>/dev/null; then
      prepare_kernel_opts \${ARCH}
    else
      do_exec cp ${DATA_DIR}/kernel/${ARCH}/${KERNEL_SOURCES} /usr/src/linux/.config
    fi
    do_exec cd /usr/src/linux || error "Failed to switch to kernel source directory"

    if ${MENUCONFIG}; then
      do_exec make menuconfig
      do_exec make ${MAKEOPTS} 1>/dev/null
    else
      do_exec make ${MAKEOPTS} 1>/dev/null
    fi

    do_exec make modules_install 1>/dev/null
    einfo "\${RED}\${ARCH}\${NOCOLOR} kernel compiled, preparing initramfs image"
    do_exec prepare_initramfs
  fi

  do_exec cd /usr/src/linux || error "Failed to switch to kernel source directory"
  do_exec cp arch/\${ARCH}/boot/bzImage /boot/vmlinuz
  do_exec update-modules 

  einfo "Compiling \${BLUE}lvm2\${NOCOLOR}"
  do_exec ${PMS} lvm2 1>/dev/null
  
  einfo "Done with \${RED}\${ARCH}\${NOCOLOR} kernel"
  if ${LETMEIN}; then
    einfo "letmein flag used. Type \${RED}exit\${NOCOLOR} when finished to continue with build."
    exec /bin/bash -i
  fi
}

prepare_useropts() {
  einfo "Setting root password to \"\${RED}${ROOT_PASSWD}\""

  # Set the livecd root password according to --root-passwd otherwise use "gentoo" for root
  echo "root:${ROOT_PASSWD}" | chpasswd 1>/dev/null # BUG #275555
  einfo "Root passwd set to \${RED}\"${ROOT_PASSWD}\""
}

diff () { printf '%s' \$(( \$(date -u -d"\$TARGET" +%s) - 
\$(date -u -d"\$CURRENT" +%s))) 
}

check_toolchain_days() {
  if [[ ${ARCH} = i586 && ! -f /etc/toolchain_age ]]; then
    ewarn "i586 needs a toolchain build, setting --force-toolchain flag"
    YES_TOOL=true
  fi
  if ${NO_TOOL}; then
    ewarn "Skipping toolchain build"
    return 1
  elif ${YES_TOOL}; then
    ewarn "Forcing a toolchain build"
    date -u -d 'now' '+%F %T.%N %Z'>/etc/toolchain_age
    return 0
  else
    # Set first start of toolchain build 
    [ ! -f /etc/toolchain_age ] && date -u -d 'now' '+%F %T.%N %Z'>/etc/toolchain_age

    local CURRENT=\$(date -u -d 'now' '+%F %T.%N %Z') TARGET=\$(</etc/toolchain_age)
    local MPHR=60 HPD=24 LIMIT=60
    # CURRENT = now, TARGET = Last time the toolchain was rebuild.
    # %F = full date, %T = %H:%M:%S, %N = nanoseconds, %Z = time zone.
    # MPHR = Minutes per hour, HPD = Hours per day, LIMIT = Days before a toolchain rebuild.
  
    DAYS=\$(( \$(diff) / \$MPHR / \$MPHR / \$HPD ))
    CURRENT=\$(date -d"\$CURRENT +\$DAYS days" '+%F %T.%N %Z')
    TOOLCHAIN_DAYS=\$(printf '%s' "\$DAYS")
    DAYS_LEFT=\$((LIMIT-TOOLCHAIN_DAYS))
      
    # If this is the first day of the build, increment date by 2 days to skip toolchain rebuild.
    if ((TOOLCHAIN_DAYS>LIMIT)); then
      ewarn "Your toolchain is \${TOOLCHAIN_DAYS} days old passed the \${LIMIT} days limit."
      date -u -d '1 day' '+%F %T.%N %Z'>/etc/toolchain_age
      einfo "Preparing to rebuild the toolchain."
      return 0
    elif ((TOOLCHAIN_DAYS==0)); then
      date -u -d '2 days' '+%F %T.%N %Z'>/etc/toolchain_age
      ewarn "You have \${DAYS_LEFT:-60} days left until your next schedule bootstrap."
      einfo "Preparing to build the toolchain."
      return 0
    else
      ewarn "You have \${DAYS_LEFT:-60} days left until your next schedule bootstrap."
      return 1
    fi
  fi
}

bootstrap() {
  # Enable livecd and user locales (see /etc/justboot/locale.gen)
  if [[ ! \$(grep '#en_US' /etc/locale.gen &>/dev/null) ]]; then
    einfo "Setting locales"
    for i in "${LOCALES[@]}" "#en_US ISO-8859-1"; do
      sed -i "s/#\${i}/\${i}/" /etc/locale.gen
    done
  fi

  # Generate locales
  do_exec locale-gen 1>/dev/null

  # Set localtime
  einfo "Setting localtime"
  [[ -e /etc/localtime ]] && do_exec rm /etc/localtime
  do_exec cp -a /usr/share/zoneinfo/UTC /etc/localtime

  einfo "Running emerge --sync"
  do_exec emerge --sync -q 1>/dev/null

  # Compile toolchain if --skip-toolchain is not set
  if ! ${NO_TOOL}; then
    # Begin the bootstrap
    einfo "Compiling the toolchain, this maybe take a while depending on hardware."
    for i in gcc-config linux-headers glibc binutils gcc portage; do
      einfo "Compiling \${BLUE}\${i}."
      do_exec ${PMS} -1 \${i} 1>/dev/null && einfo "\${BLUE}\${i}\${NOCOLOR} compiled."
    done
    do_exec gcc-config 1 1>/dev/null && do_exec env-update 1>/dev/null && do_exec source /etc/profile
  
    # Enable new gnu hash style
    [[ ! \$(grep "\-\-hash\-style\=gnu" /etc/make.conf) ]] && sed -i 's/once/once,--hash-style=gnu/' /etc/make.conf 

    # Recompile toolchain
    for i in linux-headers glibc binutils gcc; do
      einfo "Compiling \${BLUE}\${i}."
      do_exec ${PMS} -1 \${i} 1>/dev/null && einfo "\${BLUE}\${i}\${NOCOLOR} compiled."
    done
    einfo "Toolchain finished, compiling system packages against the new toolchain"

    while read ebuild; do
      einfo "Compiling \${BLUE}\"\${ebuild}\""
      do_exec ${PMS} -1 "\${ebuild}" 1>/dev/null || echo "\${ebuild}" >>failed
      einfo "\${BLUE}\"\${ebuild}\"\${NOCOLOR} compiled"
    done < <(emerge -ep --columns --color=n system | grep ebuild | awk '{print$4}' | egrep -v "(glibc|/portage|binutils|gcc|linux-h)") 

    while read ebuild; do
      einfo "Compiling \${BLUE}\"\${ebuild}\""
      do_exec ${PMS} -1 "\${ebuild}" 1>/dev/null 
      einfo "\${BLUE}\"\${ebuild}\"\${NOCOLOR} compiled"
    done < <(cat failed)
    do_exec rm failed

    python-updater &>/dev/null

    einfo "Toolchain build completed, compiling livecd packages."
  else
    einfo "Toolchain built skipped, compiling livecd packages."
  fi
}

# Script to build busybox binary inside uclibc environment
cat >> \${UCLIBC_SCRIPT} << BUSYBOX
#!/bin/bash
  env-update 1>/dev/null && source /etc/profile

  echo "Compiling Busybox."
  cd \${BUSYBOX} && make -s
  [[ ! -f busybox.links ]] && make busybox.links

  echo "Busybox has been compiled."
  exit
BUSYBOX
  do_exec prepare_configs
  do_exec check_deps
  do_exec check_toolchain_days && bootstrap
  do_exec prepare_packages
  do_exec prepare_bootloader
  do_exec prepare_busybox
  do_exec prepare_kernel
  do_exec prepare_useropts
CHROOT

# Lets go already!
[[ ! -d ${LIVEDIR} ]] && exec_chkdir ${LIVEDIR} # I trust it but i really don't.
do_exec cd ${LIVEDIR} || error "Failed to switch to livecd data directory, Exiting."
do_exec check_deps && do_exec prepare_stage
