#!/bin/bash
# JustBOOT(tm) v@VERSION@ - A Gentoo Linux LiveCD Generator.
##
# Copyright (C) 2009-2012 Mission Accomplish, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
###
version=@VERSION@
if [[ $1 =~ ^(--version|-[Vv])$ ]]; then
	echo "JustBOOT-${version} see --help for more options"
	exit 0
fi

if [ $(id -u) != 0 ]; then
	echo "This script must be run as root."
	exit 1
fi

# Set some variables
no_tool=false
yes_tool=false
letmein=false
purge=false
purge_kernel=false
ramfs=false
removal=true
menuconfig=false
delete_arch=false
verbose=false
debug=false
bash4=false

# Check for =bash-4.* associated array support
if ! declare -A &>/dev/null; then
	echo "This script uses bash4 only features, consider upgrading"
else
	bash4=true
	declare -A procs=( [i386]=M386 [i486]=M486 [i586]=M586
        [i686]=M686 [pentiumII]=MPENTIUMII [pentiumIII]=MPENTIUMIII
		[pentium-mmx]=MPENTIUMM [pentium4]=MPENTIUM4 [k6]=MK6
		[k7]=MK7 [k8]=MK8 [opteron]=MK8 [core2]=MCORE2 [core2dou]=MCORE2
		[generic]=GENERIC_CPU [x86_64]=GENERIC_CPU [atom]=MATOM )
fi

declare -a livecd_excludes=( $(grep -v '^#' \
    @confdir@/files/excluded-directories.lst ) )
declare -a remove_packages=( $(grep -v '^#'  \
    @confdir@/files/remove-packages.lst ) )
declare -a remove_files=( $(grep -v '^#'  \
    @confdir@/files/remove-files.lst ) )
declare -a ramfs_dir=( $(grep -v '^#' \
    @confdir@/files/ramfs-directories.lst ) )
declare -a extra_packages=( $(grep -v '^#' \
    @confdir@/files/extra-packages.lst ) )
declare -a arches=( x86_64 i486 i586 i686 )
declare -a locales=( $(<@confdir@/locale.gen) )

blue="$(tput setaf 4)"
red="$(tput setaf 1)"
nocolor="$(tput setaf 9)"

# Main script functions
einfo() {
	echo -e ".: "${@}" :."
	sleep 1
}
ewarn() {
	echo -e "\a${red}.: "${@}" :.${nocolor}"
}
error() {
	echo -e "\a${red}.: "${@}" :.${nocolor}"
	exit 1
}
exec_chkdir() {
	local dir="${1}"
	[[ ! -d ${dir} ]] && mkdir -p ${dir}
}
exec_chklink() {
	local src="${1}" dest="${2}"
	[[ -h ${dest} ]] && { unlink ${dest}; ln -s ${src} ${dest}; }
}
do_exec() {
  if ${debug}; then
    echo -e "\a${red}debug:${nocolor}${blue} (${@})"${nocolor}
    "${@}"
  elif ${verbose}; then
    "${@}"
  else
    "${@}" 2>/dev/null
  fi
}

# Help menu
print_help() {
cat << HELP
Usage: justboot [arguments] [make opts] [kernel opts]

Arguments:

--arch=                 - Set arch for livecd build i.e --arch=x86_64
--kernel=               - Kernel sources for livecd
--root-passwd=          - ROOT password for the livecd
--init-compression      - Currently only gzip and lzma compression is
	supported
-L, --volid=            - Set a label for the livecd image
--ramfs                 - Compile in ramfs "Must have ~4GB of available
	RAM"
--force-toolchain       - Force a rebuilt of the toolchain
--skip-toolchain        - Skips toolchain built for those in a hurry
--build-directory=       - Set the build directory for compiles
--package-manager=      - Enable the package manager for all builds
	.: Currently only pkgcore is supported, by default justboot uses
	portage :.
--letmein               - Will run interactive bash at end of chroot
	stage so you can tweak the livecd environment
--verbose               - Run in verbose mode - lots of output
--purge                 - Purge old build and start fresh
--delete-arch           - Like --purge but exits script after
--debug                 - Turn on debugging

Gentoo make.conf options:

--cflags                - Compiler FLAGS
--ldflags=              - Linker FLAGS
--make-opts=            - MAKEOPTS
--keywords=             - Accepted KEYWORDS i.e ~x86
--jobs=                 - Specifies the number of packages to build
	simultaneously
--use=                  - Packages USE flags
--features=             - make.conf specific FEATURES
--gentoo-mirrors=       - JustBOOT and make.conf space separated list
	of local mirrors
--rsync-mirror=         - Sets the default rsync mirror
--niceness=             - make.conf specific PORTAGE_NICENESS

Linux Kernel options: >=bash-4.0 Only

--coprocessor=          - Processor type for the livecd kernel i.e
	--coprocessor=core2
--coprocessor-list      - List the currently supported coprocessors
--menuconfig            - Runs make menuconfig for interactive kernel
	configuration
--purge-kernel          - Purge any kernel sources and start fresh

Usage examples:

Generate a x86_64 livecd using gentoo-sources and set 'gentoo'
    for root password
# justboot --arch=x86_64 --root-passwd="gentoo"

Generate a i686 livecd with 'let me in!' as password and 'gentoo' for
    livecd label
# justboot --arch=i686 --volid="gentoo rocks" --root-passwd="let me in!"

Generate a x86_64 livecd with optional gzip compression
    (Default is to use lzma)
# justboot --arch=x86_64 --init-compression lzma

Generate a livecd but compile packages in ram (see
    @confdir@/files/ramfs-directories.lst)
# justboot --arch=x86_64 -ramfs -L "Fast is good"

Generate a livecd but delete old sources first.
# justboot --arch=x86_64 --purge

Generate a livecd for x86_64 using -j8 for makeopts and -19 for portage
    niceness
# justboot --arch=x86_64 --make-opts="-j8" --niceness="-19"

Change the livecd build directory
# justboot --arch=x86_64 --build-directory=/home/username

Change the rsync and gentoo mirrors setting
# justboot --arch=i486 --gentoo-mirrors="http://mirror.datapipe.net/gentoo
	ftp://gentoo.chem.wisc.edu/gentoo/"
    --rsync-mirror="http://localhost/portage"

Generate a livecd for opteron processors
# justboot --coprocessor=opteron --arch=x86_64 --cflags="-march=opteron
    -Os -pipe" --make-opts=-j3

Generate a livecd for an Intel Core2 Quad processor
# justboot --coprocessor=core2 --arch=x86_64 --cflags="-march=core2 -Os -pipe"
    --make-opts=-j5

Generate a x86_64 livecd with interactive kernel menu and custom rsync mirror
# justboot --arch=x86_64 --menuconfig --make-opts=-j5
	--rsync-mirror="http://localhost/portage"

Use sys-apps/pkgcore for all livecd builds instead of portage
# justboot --arch=i486 --package-manager=pkgcore --root-passwd=letmein

Remove old sources (This deletes all livecd build for that arch)
# justboot --arch=i586 --delete-arch
 
HELP
exit 0
}

einfo "${blue}JustBOOT(tm)${nocolor} initiated"

# Parse Command Line Arguments
while [ $# -gt 0 ]; do
    case "$1" in
        --arch=*)
            arch="${1#*=}"
            einfo "${blue}${arch}${nocolor} arch set"
            ;;
        --cflags=*)
            CFLAGS="${1#*=}"
            einfo "CFLAGS set to ${blue}\"${CFLAGS}\""
            ;;
        --ldflags=*) LDFLAGS="${1#*=}";;
        --kernel=*)
            kernel_sources="${1#*=}"
            einfo "${blue}${kernel_sources} kernel set"
            ;;
        --root-passwd=*)
            root_passwd="${1#*=}"
            einfo "Setting ${red}\"${root_passwd}\"${nocolor} as \
                livecd root password"
            ;;
        --keywords=*)
            ACCEPT_KEYWORDS="${1#*=}"
            einfo "Setting ${blue}${ACCEPT_KEYWORDS}${nocolor} for \
                make.conf"
            ;;
        --ramfs)
            ram_limit=4194304
            ram_size=$(sed -n 2p /proc/meminfo | awk '{print$2}')
            
            if [[ $ram_size > $ram_limit ]]; then
                einfo "${red}ramfs${nocolor} compiles enabled!!!"
            else
                ewarn "You have ${ram_size} of free memory and you \
                    need >=${ram_limit}, --ramfs not enabled."
            fi
            ;;
        --init-compression)
            init_compression="${2}"
            einfo "Using ${blue}${init_compression}${nocolor} for \
                initramfs compression"
            shift
            ;;
        --volid=*|-L)
            if [ ${1%%=*} = -L ]; then
                volid="${2// /_}"
                [ ${#volid} -gt 32 ] && error "${nocolor}Volume \
                    label ${red}\"${volid//_/ }\"${nocolor} is \
                    greater than the 32 allowed characters"
                shift
            else
                arg=${1##*=}
                volid="${arg// /_}"
                [ ${#volid} -gt 32 ] && error "${nocolor}Volume \
                    label ${red}\"${volid//_/ }\"${nocolor} is \
                    greater than the 32 allowed characters"
            fi
 
            einfo "Using ${red}\"${volid//_/ }\"${nocolor} for \
                livecd label"
            ;;
        --build-directory=*)
            dir="${1#*=}"
            livedir="${dir/%\//}/justboot" # Remove leading slash
            einfo "Livecd build directory set to \
                ${blue}\"${livedir}\"${nocolor}"
            ;;
        --package-manager=*)
            [[ -f @confdir@/${arch}-pms ]] && error "Previously \
                enabled package manager, delete \
                @confdir@/${arch}-pms then try again to override"

            [[ ${1#*=} =~ ^(pkgcore|portage)$ ]] || { einfo \
                "--package-manager=${red}${1##*=}${nocolor} is \
                invalid, try pkgcore or portage"; error "Exiting!"; }

            if [[ ${1#*=} = portage ]]; then
                pms="emerge -q"
            else 
                pms="pmerge"
            fi
            
            einfo "${red}${pms}${nocolor} permanently enabled, \
                to override delete @confdir@/${arch}-pms"
            
            touch @confdir@/${arch}-pms # FIX/IMPROVE ME 
            ;; 
        --gentoo-mirrors=*)
            opt="$(echo ${1#*=} | awk '{print$1}')"
            gentoo_mirror="${opt/%\/}"
            GENTOO_MIRRORS="${1#*=}"
            ;;
        --rsync-mirror=*) SYNC="${1#*=}";;
        --menuconfig) menuconfig=true;;
        --force-toolchain) yes_tool=true;;
        --skip-toolchain) no_tool=true;;
        --lang=*) LINGUAS="${1#*=}";;
        --niceness=*) PORTAGE_NICENESS="${1#*=}";;
        --use=*) USE="${1#*=}";;
        --make-opts=*) MAKEOPTS="${1#*=}";;
        --jobs=*) jobs="${1#*=}";;
        --ldflags=*) LDFLAGS="${1#*=}";;
        --features=*) FEATURES="${1#*=}";;
        --letmein) letmein=true;;
        --purge) purge=true;;
        --purge-kernel) purge_kernel=true;;
        --delete-arch) delete_arch=true;;
        --coprocessor=*)
            cpu="${1#*=}"
            if [[ ${bash4} && -z ${procs[${cpu}]} ]]; then
                ewarn "${cpu} is an invalid --coprocessor option."
                einfo "Available procs are: ${blue}${!procs[@]}"
                ewarn "Exiting now."
                exit 1
            fi
            ;;
        --coprocessor-list)
            if ${bash4}; then
                einfo "Available procs are: ${blue}${!procs[@]}"
                exit 0
            else
                einfo "Available procs are: ${blue}i386,i486,i586,i686\
                    ,k6,k7,k8,opteron,core2,atom,pentiumII,pentiumIII \
                    pentium4 & generic"
                exit 0
            fi
            ;;
        --verbose) verbose=true;;
        --debug|-db) debug=true; einfo "Running in debug mode";;
        --help|-h) print_help;;
        *) error "${blue}Invalid argument ${red}${1}!${nocolor}, \
            run \"$0 --help\" for help."
    esac
    shift
done

# Check that we are using a valid $arch
for i in ${arches[@]}; do
    if [[ ${arch} != ${i} ]]; then
        invalid_arch=true
    else 
        invalid_arch=false
        break
    fi
done

${invalid_arch} && { einfo "${red}${arch}${nocolor} arch is \
invalid, valid options are ${arches[*]}"; error "Exiting!!!"; }

# Convert arch value for /etc/make.conf
case ${arch} in
    x86_64)
        make_arch=x86-64
        [[ ${ACCEPT_KEYWORDS} ]] || make_keywords="~x86 ~amd64"
        ;;
    i[4,5,6]86)
        [[ ${ACCEPT_KEYWORDS} ]] || make_keywords="~x86"
esac

# Allow for user default $arch options i.e ~/.justboot/x86_64.conf
[ -f ~/.justboot/${arch}.conf ] && . ~/.justboot/${arch}.conf

# When no --build-directory is set we default to /var/tmp/justboot, but
# first we check for an existing $arch symbolic link, so our $livedir
# always points to the correct arch path

if [[ -h /var/tmp/justboot/${arch} && ! ${livedir} ]]; then
    link=$(readlink /var/tmp/justboot/${arch})
    livedir=${link/\/${arch}/}
    data_dir=@datdir@
    arch_dir=${livedir}/${arch}
    excludes_dir=${livedir}/excludes/${arch}
fi

# Source JustBOOT(tm) global configuration options
. @confdir@/config.globals

# Check if we previously set a package manager for compiles on $arch
if [ ! -f @confdir@/${arch}-pms ]; then
    pms="emerge -q"
else
    pms=$(<@confdir@/${arch}-pms)
fi

# Remove old build directories (--purge/--delete-arch)
if ${purge} || ${delete_arch}; then
    [[ ! -h /var/tmp/justboot/${arch} && \
        ! -d /var/tmp/justboot/${arch} ]] && { einfo "No arch to \
            purge or remove! Exiting"; exit 1; }

    src=$(readlink /var/tmp/justboot/${arch})
    einfo "${red}--purge or --delete-arch flag used.${nocolor} \
        Removing ${red}${arch}${nocolor} sources."

    if [[ -h /var/tmp/justboot/${arch} ]]; then
        do_exec rm -rf $(readlink /var/tmp/justboot/excludes/${arch})
        do_exec rm -rf $(readlink /var/tmp/justboot/${arch})
        
        for i in /var/tmp/justboot/excludes/${arch} \
            /var/tmp/justboot/${arch}; do
                do_exec unlink ${i}
        done

    elif [ -d /var/tmp/justboot/${arch} ]; then
        do_exec rm -rf /var/tmp/justboot/${arch} \
            /var/tmp/justboot/excludes/${arch}
    fi

    for i in i{4,5,6}86 x86_64; do
        [[ ${i} = ${arch} ]] && continue 2
        [[ -d ${src/${arch}/${i}} ]] && { removal=false; einfo \
            "${red}${src/${arch}/${i}}${nocolor} arch found, deleting \
            ${src} only"; break; }
    done

    if ${removal}; then
        ewarn "Removing orphan build directory ${red}${src/\/${arch}}\
            ${nocolor}"
        do_exec unlink ${src/\/${arch}//data} 
        do_exec rm -rf ${src/\/${arch}}
    fi

    ${delete_arch} && { einfo "All done ${arch} sources removed, \
        exiting"; exit 0; }
fi

# The stage in which we umount all livecd build and copy any --ramfs
# changes to the excluded directories.  First we remove local livecd
# folders i.e proc,dev and the build directory, then we copy any ramfs
# changes to the livecd exclude folders. See the
# @confdir@/files/{ramfs-directories,excluded-directories}.lst file to
# customize

release_env() {
einfo "Releasing livecd environment, please wait..."
do_exec rm -rf ${arch}/tmp/* 
do_exec umount ${arch_dir}/{proc,dev} ${arch}${data_dir}

if ${ramfs}; then
    for x in "${livecd_excludes[@]}"; do
        for y in "${ramfs_dir[@]}"; do
            if [[ ${x} = ${y} ]]; then
                einfo "Removing ${red}${x}${nocolor} from memory. \
                    please wait..."
                do_exec rsync -caq --delete-before \
                    ${arch}/${x}/* ${excludes_dir}/${x//\//:} &>/dev/null
                do_exec umount ${arch}/${x} &>/dev/null
                einfo "Copied ${blue}${x}${nocolor} changes to \
                ${red}${excludes_dir}/${x//\//:}${nocolor}"
            continue 2
            fi
        done
        do_exec umount ${arch}/${x} &>/dev/null
    done

    for x in "${ramfs_dir[@]}"; do
        for y in "${livecd_excludes[@]}"; do
            [[ ${x} = ${y} ]] && continue 2
        done

    einfo "Removing ${red}${x}${nocolor} from memory. please wait..."
    do_exec rsync -caq --delete-before ${arch}/${x}/* \
        ${excludes_dir}/${x//\//:} &>/dev/null
    do_exec umount ${arch}/${x} \
        &>/dev/null
    einfo "Copied ${blue}${x}${nocolor} changes to \
        ${red}${excludes_dir}/${x//\//:}${nocolor}"
    done
else
    for x in "${livecd_excludes[@]}"; do
        do_exec umount ${arch}/${x} &>/dev/null
    done
fi

[ ! $1 ] && do_exec clean_env
}

trap 'release_env now; exit 13' TERM INT
#  Cleans up the livecd environment if script is interrupted by
#  Control-C.

# Check local system for required packages
check_deps() {
local -a deps=( 'mksquashfs:sys-fs/squashfs-tools'
    'mkisofs:virtual/cdrtools' )

if [[ "${pms}" = pmerge ]]; then
    if ! hash pmerge &>/dev/null; then
        einfo "Compiling ${blue}sys-apps/pkgcore${nocolor}"
        do_exec emerge pkgcore 1>/dev/null
        einfo "${blue}sys-apps/pkgcore${nocolor} compiled"
    fi
fi

for i in ${deps[@]}; do
    if ! hash ${i/:*/} &>/dev/null; then
        einfo "Compiling ${blue}${i/*:/}${nocolor}"
        do_exec ${pms} ${i/*:/} 1>/dev/null
        einfo "${blue}${i/*:/}${nocolor} compiled"
    fi
done
}

# Preparation of the stage1 build - we skip most of this and only run
# through half of it once unless we are starting fresh or ran justboot
# with --purge argument.
prepare_stage() {
if [[ ! -d ${arch_dir} || ${livedir} = /var/tmp/justboot ]]; then
    if [ -h /var/tmp/justboot/${arch} ]; then
        local real_arch_dir=$(readlink /var/tmp/justboot/${arch})
        local real_excludes_dir=$(readlink \
            /var/tmp/justboot/excludes/${arch})

        einfo "Moving build directory from ${red}${real_arch_dir}\
            ${nocolor} to ${red}${livedir}/${arch}${nocolor}. \
            please wait..."

        for i in /var/tmp/justboot/${arch} \
            /var/tmp/justboot/excludes/${arch}; do
            do_exec unlink ${i}
        done

        exec_chkdir ${livedir}/excludes
        do_exec mv ${real_arch_dir} ${arch_dir}
        do_exec mv ${real_excludes_dir} ${excludes_dir}

        if [[ ${livedir} != /var/tmp/justboot ]]; then
            exec_chklink ${arch_dir} /var/tmp/justboot/${arch}
            exec_chklink ${livedir}/excludes/${arch} \
                /var/tmp/justboot/excludes/${arch}
            exec_chklink @datdir@ ${data_dir}
        fi

        for i in i{4,5,6}86 x86_64; do
            [[ ${i} = ${arch} ]] && continue 2
            [[ -d ${real_arch_dir/${arch}/${i}} ]] && \
                { removal=false; break; }
        done

        if ! ${removal}; then
            ewarn "Removing old build directory \
                ${red}${real_arch_dir/\/${arch}}${nocolor}"
            do_exec unlink ${real_arch_dir/\/${arch}//data}
            do_exec rm -rf ${real_arch_dir/\/${arch}/}
        else
            ewarn "Removing old build directory ${red}\
                ${real_arch_dir}${nocolor}"
            do_exec rm -rf ${real_arch_dir} ${real_excludes_dir}
        fi
    elif [[ /var/tmp/justboot != ${livedir} && \
        -d /var/tmp/justboot/${arch} ]]; then

        einfo "Moving build directory from ${red}/usr/share/\
            justboot/${arch}${nocolor} to ${red}${livedir}/${arch}\
            .${nocolor} please wait..."

        exec_chkdir ${livedir}/excludes
        do_exec mv /var/tmp/justboot/${arch} ${arch_dir}
        do_exec mv /var/tmp/justboot/excludes/${arch} ${excludes_dir}

        exec_chklink ${arch_dir} /var/tmp/justboot/${arch}
        exec_chklink ${livedir}/excludes/${arch} \
            /var/tmp/justboot/excludes/${arch}
        exec_chklink @datdir@ ${data_dir}
    fi
fi

# Convert x86_64 arch for proper usage in Gentoo.
case ${arch} in
    x86_64) local gentoo_arch=amd64 stage_arch=amd64;;
    i[4,5,6]86) local gentoo_arch=x86 stage_arch=i686
esac

[[ ! -d ${arch_dir}/build ]] && { ewarn "Stage extraction was incomplete \
    or interrupted by user"; rm -rf ${arch_dir}; }

if [ ! -d ${arch_dir} ]; then
    einfo "Building initial stage1 for ${blue}${arch}${nocolor}. \
        please wait..."

    do_exec wget -q ${gentoo_mirror}/releases/${gentoo_arch}/autobuilds/\
latest-stage3.txt

    local gentoo_stage=$(egrep -o \
        [[:digit:]]{8}/stage3-${stage_arch}-[[:digit:]]{8}.tar.bz2 \
        latest-stage3.txt)
    do_exec rm latest-stage3.txt

    exec_chkdir ${arch_dir} 
    do_exec cd ${arch_dir} || error "Failed to switch to ${arch_dir}"

    einfo "Fetching gentoo ${gentoo_stage#*/} autobuild stage"
    do_exec wget -q ${gentoo_mirror}/releases/${gentoo_arch}\
/autobuilds/${gentoo_stage}

    einfo "Extracting ${gentoo_stage#*/}"
    do_exec tar xjpf ${gentoo_stage#*/}
    do_exec rm ${gentoo_stage#*/}

    einfo "Fetching portage tree snapshot"
    do_exec wget -q ${gentoo_mirror}/snapshots/portage-latest.tar.bz2

    einfo "Extracting portage-latest.tar.bz2"
    do_exec tar xjpf portage-latest.tar.bz2 -C usr/
    do_exec rm portage-latest.tar.bz2

    exec_chkdir ${excludes_dir}
    exec_chkdir /var/tmp/justboot/excludes

    for i in "${livecd_excludes[@]}"; do
      exec_chkdir ${excludes_dir}/${i//\//:}
      do_exec mv ${i}/* ${excludes_dir}/${i//\//:} &>/dev/null
    done

    einfo "Done with stage1 for ${blue}${gentoo_arch}.${nocolor}"
    touch ${arch_dir}/build

    if [[ ${livedir} != /var/tmp/justboot ]]; then
      exec_chklink ${arch_dir} /var/tmp/justboot/${arch}
      exec_chklink ${livedir}/excludes/${arch} \
        /var/tmp/justboot/excludes/${arch}
      exec_chklink @datdir@ ${data_dir}
    fi
fi
  do_exec prepare_env
}

# After we have prepared the stage1 build, we need to detect/setup all
# the livecd exclude directories and or ramfs mounts first before we
# start the chroot process and compile packages
prepare_env() {
cd ${livedir}
exec_chkdir ${arch_dir}${data_dir}
exec_chkdir ${arch_dir}/mnt/gentoo

do_exec mount -o bind /proc ${arch}/proc
do_exec mount -o bind /dev ${arch}/dev
do_exec mount -o bind ${data_dir} ${arch}${data_dir}

for x in "${livecd_excludes[@]}"; do
    if [[ $(ls ${arch}/${x//://} 2>/dev/null | grep -v .keep | wc -l)\
        != 0 ]]; then
        einfo "Detected newly added ${blue}${x}${nocolor} for livecd \
            excludes, moving build to ${red}${excludes_dir}/${x//\//:}\
            .${nocolor} please wait..."
        exec_chkdir ${excludes_dir}/${x//\//:}
        do_exec mv ${arch}/${x}/* ${excludes_dir}/${x//\//:} &>/dev/null
        do_exec rm -rf ${arch}/${x}/*
    fi
done

if ${ramfs}; then
    for x in "${livecd_excludes[@]}"; do
        for y in "${ramfs_dir[@]}"; do
            if [[ ${x} = ${y} ]]; then
                einfo "Mounting ${blue}${x}${nocolor} in memory. \
                    please wait..."
                do_exec mount -t ramfs ${x} ${arch}/${x} 1>/dev/null

                [[ ! -d ${excludes_dir}/${x//\//:} ]] && \
                    exec_chkdir ${excludes_dir}/${x//\//:}
                do_exec rsync -caq ${excludes_dir}/${x//\//:}/* \
                    ${arch}/${x} &>/dev/null

                einfo "${red}${x}${nocolor} copied to ramfs"
                continue 2
            fi
        done
        do_exec mount -o bind ${excludes_dir}/${x//\//:} \
            ${arch}/${x} 1>/dev/null
    done

    for x in "${ramfs_dir[@]}"; do
        for y in "${livecd_excludes[@]}"; do
            [[ ${x} = ${y} ]] && continue 2
        done
        einfo "Mounting ${blue}${x}${nocolor} in memory.. please wait."

    if [[ $(ls ${arch}/${x} 2>/dev/null | grep -v .keep | wc -l)\
        != 0 ]]; then
        exec_chkdir ${excludes_dir}/${x//\//:}
        einfo "${blue}${arch}/${x}${nocolor} is not empty, moving \
            build to ${red}${excludes_dir}/${x//\//:}.${nocolor} \
            please wait..."
        do_exec mv ${arch}/${x}/* ${excludes_dir}/${x//\//:}\
            &>/dev/null
    else

        for i in ${arch}/${x} ${excludes_dir}/${x//\//:}; do
            exec_chkdir ${i}
        done
    fi

    do_exec mount -t ramfs ${x} ${arch}/${x} 1>/dev/null

    if [[ -d ${excludes_dir}/${x//\//:} ]]; then
        do_exec rsync -caq ${excludes_dir}/${x//\//:}/* \
            ${arch}/${x} &>/dev/null
        einfo "${red}${x}${nocolor} copied to ramfs"
    fi
    done

    (
    cd ${excludes_dir}
    declare -a dirs=( * )
    for x in "${dirs[@]}"; do
        for y in "${livecd_excludes[@]}" "${ramfs_dir[@]}"; do
            [[ ${x} = ${y//\//:} ]] && continue 2
        done

    einfo "${blue}${x}${nocolor} is an orphan directory."
    einfo "Moving build to ${red}${arch}/${x//://}.${nocolor} \
        please wait..."
    do_exec mv ${excludes_dir}/${x}/* ${arch}/${x//://} \
        &>/dev/null
    do_exec rm -rf ${excludes_dir}/${x}
    done
    )
else
    (
    cd ${excludes_dir}
    declare -a dirs=( * )

    for x in "${dirs[@]}"; do
        for y in "${livecd_excludes[@]}"; do
        [[ ${x} = ${y//\//:} ]] && continue 2
        done

        einfo "${blue}${x}${nocolor} is either an orphan directory \
            or part of an old ${blue}ramfs (--ramfs)${nocolor} run."
        einfo "Moving build to ${red}${arch}/${x//://}.${nocolor} \
            please wait..."
        do_exec mv ${excludes_dir}/${x}/* ${arch}/${x//://} &>/dev/null
        do_exec rm -rf ${excludes_dir}/${x}
    done
    )

    einfo "Mounting livecd build files"
    for i in "${livecd_excludes[@]}"; do
        do_exec mount -o bind ${excludes_dir}/${i//\//:} ${arch}/${i} \
            1>/dev/null
    done
fi

[[ ! -d ${arch_dir}/mnt/livecd ]] && do_exec mkdir -p ${arch_dir}/mnt/\
livecd/{static,image,dynamic}

einfo "Entering the livecd chroot environment"

do_exec chmod +x ${chroot_script} && do_exec mv ${chroot_script} \
    ${arch_dir}/tmp
do_exec cp /etc/resolv.conf ${arch_dir}/etc

if [[ ${arch} =~ ^i[4-6]86$ ]]; then
    do_exec linux32 chroot ${arch_dir} ${chroot_script} && \
        do_exec rm ${arch_dir}${chroot_script}
else
    do_exec linux64 chroot ${arch_dir} ${chroot_script} && \
        do_exec rm ${arch_dir}${chroot_script}
fi

[ $? = 13 ] && do_exec release_env now

einfo "Exiting the livecd chroot environment"
do_exec env-update 1>/dev/null && do_exec source /etc/profile
do_exec release_env 
}

# Before we create our iso image we will clean up the environment of any
# excluded packages and common directories or files that we don't
# require for livecd operations ( see
# @confdir@{excluded-directories,remove-packages,remove-files}.lst for
# options.
clean_env() {

local target=${livedir}/targets/${arch}/targets/files/${arch} 
local cleanup_script=$(mktemp /tmp/XXX)

[[ -d ${target} ]] && do_exec rm -rf ${target}/* \
    ${livedir}/targets/${arch}/boot/* ${livedir}/targets/${arch}/\
        targets/boot/*

for i in "${target}" "${livedir}/targets/${arch}/targets/boot" \
    "${livedir}/targets/${arch}"; do
    exec_chkdir ${i}
done

einfo "Performing livecd cleanup. please wait..."
do_exec cp -a ${arch_dir}/* ${target} &>/dev/null

if [[ -d ${excludes_dir}/boot ]]; then
    do_exec cp -a ${excludes_dir}/boot ${livedir}/targets/\
        ${arch}/targets 
    do_exec cp -a ${excludes_dir}/boot ${livedir}/targets/${arch}
else
    do_exec cp -a ${arch_dir}/boot ${livedir}/targets/${arch}/targets
    do_exec cp -a ${arch_dir}/boot ${livedir}/targets/${arch}
fi

for i in "${livecd_excludes[@]}"; do
    if [[ $(ls ${excludes_dir}/${i//\//:} 2>/dev/null | grep -v .keep \
        | wc -l) != 0 ]]; then
        einfo "Moving ${blue}${i}${nocolor} to ${red}${target}/\
            ${i}.${nocolor} please wait..."
        do_exec cp -a ${excludes_dir}/${i//\//:}/* ${target}/${i} \
            &>/dev/null  
    fi
done

if ${ramfs}; then
    for x in "${ramfs_dir[@]}"; do
        for y in "${livecd_excludes[@]}"; do
            [[ ${x} = ${y} ]] && continue 2
        done

        if [[ $(ls ${excludes_dir}/${x//\//:} 2>/dev/null | grep -v \
            .keep | wc -l) != 0 ]]; then
            einfo "Moving ${blue}${x}${nocolor} to ${red}${target}/\
                ${x}.${nocolor} please wait..."
            do_exec cp -a ${excludes_dir}/${x//\//:}/* ${target}/\
                ${x} &>/dev/null
        fi
    done
fi

cat >> ${cleanup_script} << CLEANUP
#!/bin/bash
trap 'echo "User interrupted, Exiting"; exit $USER_INTERRUPT' TERM INT
# Cleans up the environment if script interrupted by control-c.

echo "Entering livecd environment"
env-update 1>/dev/null && source /etc/profile

for i in ${remove_packages[@]}; do
    echo "Removing \${i} from livecd"
    ${pms} -C \${i} &>/dev/null
done

echo -e "${red}${#remove_packages[@]}${nocolor} Packages removed"
exit
CLEANUP

do_exec chmod +x ${cleanup_script} && \
    do_exec mv ${cleanup_script} ${target}/tmp

if [[ ${arch} =~ ^i[4-6]86$ ]]; then
    do_exec linux32 chroot ${target} ${cleanup_script}
else
    do_exec linux64 chroot ${target} ${cleanup_script}
fi

[ $? = 13 ] && do_exec release_env now

do_exec cd ${target}
do_exec rm -rf ${remove_files[@]} ${livecd_excludes[@]}

for i in boot var/run/dbus var/lock/subsys var/cache/edb/deb \
    var/cache/hald var/log root var/log; do
    do_exec exec_chkdir ${i}
done

>etc/mtab

do_exec create_livecd
}

# Livecd creation
create_livecd() {
local date=$(date +%m%d%Y-%H%M)
do_exec touch ${livedir}/targets/${arch}/targets/livecd

einfo "Building squashfs image"
do_exec mksquashfs ${livedir}/targets/${arch}/targets/files/${arch}/ \
    ${livedir}/targets/${arch}/targets/livecd.squashfs

einfo "Generating bootable JustBOOT(tm) livecd image"
do_exec mkisofs -volid \"${volid}\" -R -b boot/grub/stage2_eltorito \
    -no-emul-boot -boot-load-size 4 -boot-info-table -iso-level 4 \
    -hide-rr-moved -c boot.catalog -o \
    ${livedir}/${arch}-${kernel_sources}-${date}.iso -x files \
    ${livedir}/targets/${arch}/targets/
  
do_exec rm -rf ${livedir}/targets/${arch}/{targets,boot}

einfo "All Done. ${arch} livecd located at \
    ${livedir}/${arch}-${kernel_sources}-${date}.iso"
}

cat >> ${chroot_script} << CHROOT
#!/bin/bash
arch=${arch}
uclibc="/var/tmp/justboot/uclibc"
uclibc_script=\$(mktemp /tmp/XXX)
uclibc_src_uri="http://gentoo.mirrors.tds.net/gentoo/experimental/\
x86/embedded/stages/stage3-x86-uclibc-2008.0.tar.bz2"
busybox_src_uri="http://busybox.net/downloads/busybox-1.17.2.tar.bz2"
busybox_archive=\$(echo \${busybox_src_uri} | egrep -o \
    'busybox-[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.tar\.bz2')
busybox_conf=${data_dir}/busybox/.config
busybox=\${busybox_archive/.tar.bz2/}
blue="\$(tput setaf 4)"
red="\$(tput setaf 1)"
nocolor="\$(tput setaf 9)"

trap 'echo "User interrupted, Exiting"; exit $USER_INTERRUPT' TERM INT
# Cleans up the environment if script interrupted by control-c.

env-update 1>/dev/null && source /etc/profile

einfo() {
    echo -e ".: "\${@}" :."
    sleep 1
}
ewarn() {
    echo -e "\a\${red}.: "\${@}" :.\${nocolor}"
}
error() { 
    echo -e "\a\${red}.: "\${@}" :.\${nocolor}"
    exit 1
}
exec_chklink() {
    local src="\${1}" dest="\${2}"
    [[ -h \${dest} ]] && { unlink \${dest}; ln -s \${src} \${dest}; }
}

do_exec() {
if ${debug}; then
    echo -e "\a\${red}debug:\${nocolor}\${blue} (\${@})"\${nocolor}
    "\${@}"
elif ${verbose}; then
    "\${@}"
else
    "\${@}" 2>/dev/null
fi
}

check_deps() {
# Check for pkgcore if --package-manager=pkgcore is used"
if [[ "${pms}" = pmerge ]]; then
    if ! hash pmerge &>/dev/null; then
        einfo "Compiling \${blue}sys-apps/pkgcore\${nocolor}"
        do_exec emerge pkgcore 1>/dev/null
    fi
fi
}

prepare_configs() {
do_exec cp -a ${data_dir}/etc/{fstab,portage} /etc
do_exec cp -a ${data_dir}/etc/conf.d/{hostname,net,clock} /etc/conf.d

if [[ ! \$(grep JustBOOT /etc/make.conf 2>/dev/null) ]]; then
    >/etc/make.conf
# Generate our make.conf if this is a new livecd build.
cat >> /etc/make.conf << MAKECONF
# /etc/make.conf generated by the JustBOOT(tm) livecd generator
#
CFLAGS="${CFLAGS}"
CHOST="${CHOST}"
CXXFLAGS="${CFLAGS}"
MAKEOPTS="${MAKEOPTS}"
LDFLAGS="${LDFLAGS}"
USE="${USE}"
LINGUAS="${LINGUAS}"
FEATURES="${FEATURES}"
PORTAGE_NICENESS="${PORTAGE_NICENESS}"
ACCEPT_KEYWORDS="${ACCEPT_KEYWORDS}"
PORT_LOGDIR=/var/log/portage
SYNC="${SYNC}"
GENTOO_MIRRORS="${GENTOO_MIRRORS}"
CLEAN_DELAY="1"
EMERGE_WARNING_DELAY="1"
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS}"
MAKECONF
fi
}

# Prepare the livecd required and user packages.
prepare_packages() {
local -a global_packages=( 'grub:sys-boot/grub' 'net-setup:app-misc/
    livecd-tools' 'lshw:sys-apps/lshw' 'mkfs.reiser4:sys-fs/
    reiser4progs' 'mkfs.jfs:sys-fs/jfsutils' 'mkfs.xfs:sys-fs/
    xfsprogs' 'mkfs.reiserfs:sys-fs/reiserfsprogs' 'mdadm:sys-fs/
    mdadm' 'screen:app-misc/screen' 'rsync:net-misc/rsync' 'dhcpcd:
    net-misc/dhcpcd' 'ntpd:net-misc/openntpd' 'sudo:app-admin/sudo' )

einfo "Preparing livecd and user packages. please wait..."
for i in \${global_packages[@]}; do
    if ! hash \${i/:*/} &>/dev/null; then 
        einfo "Compiling \${blue}\${i/*:/}\${nocolor}"
        do_exec ${pms} \${i/*:/} 1>/dev/null
    fi
done

for i in ${extra_packages=[@]}; do
    if ! hash \${i/:*/} &>/dev/null; then
        einfo "Compiling \${blue}\${i}\${nocolor}"
        do_exec ${pms} \${i/*:/} 1>/dev/null
    fi
done

if ! hash memtest86+ &>/dev/null; then
    do_exec ${pms} memtest86+ 1>/dev/null
fi

# Setup sudoers
[ -f /etc/sudoers ] && sed -i '/NOPASSWD: ALL/ s/^# //' /etc/sudoers
}

prepare_bootloader() {
[ -h /boot/grub/menu.lst ] && do_exec unlink /boot/grub/menu.lst

# Always a fresh grub.conf, eventually it will parse for changes then
# update.
>/boot/grub/menu.lst

cat >> /boot/grub/menu.lst << GRUB
default 0
timeout 3
splashimage=/boot/grub/splash.xpm.gz

title=JustBOOT
        kernel /boot/vmlinuz root=/dev/loop0 vga=ask
        initrd /boot/${arch}-initramfs_data.cpio.${init_compression}
title=JustBOOT NO-FB
        kernel /boot/vmlinuz root=/dev/loop0
        initrd /boot/${arch}-initramfs_data.cpio.${init_compression}
title=Memtest86+
        kernel /boot/memtest86plus/memtest.bin
GRUB
do_exec cp /boot/grub/menu.lst /boot/grub/grub.conf
}

fetch_busybox() { # TODO: make this work for other archives.
einfo "Fetching Busybox sources"
do_exec wget -q \${busybox_src_uri}

einfo "Extracting Busybox sources"
do_exec tar xvjpf \${busybox_archive}
}

prepare_busybox() {
if [[ ! -d \${uclibc} ]]; then
    do_exec mkdir -p \${uclibc}
    do_exec cd \${uclibc}

    einfo "Fetching Gentoo UCLIBC stage3 tarball"
    do_exec wget -q \${uclibc_src_uri}

    einfo "Extracting Gentoo uclibc stage3 tarball"
    do_exec tar xjpf stage*
    do_exec fetch_busybox
elif  [[ ! -d \${uclibc}/\${busybox} ]]; then
    do_exec cd \${uclibc} && do_exec fetch_busybox
fi

do_exec cp -a ${data_dir}/busybox/.config \${uclibc}/\${busybox}

einfo "Entering uclibc environment"
do_exec chmod +x \${uclibc_script} && do_exec mv \${uclibc_script} \${uclibc}/tmp
do_exec linux32 chroot \${uclibc} \${uclibc_script}

einfo "Done with busybox build"
}

# The setup of our initramfs image
prepare_initramfs() {
local initramfs_dir=/tmp/initramfs
local kernel_src=\$(readlink /usr/src/linux)
local kernel_module_src=\${kernel_src%*-}

[[ -d \${initramfs_dir} ]] && do_exec rm -rf \${initramfs_dir}
do_exec mkdir \${initramfs_dir} && do_exec cd \${uclibc}/\${busybox}
./applets/install.sh \${initramfs_dir} --symlinks 1>/dev/null

do_exec cd \${initramfs_dir}
do_exec mkdir -p proc sys dev mnt new-root lib mnt/livecd \
mnt/livecd/{static,dynamic,image} lib/modules

do_exec cp -a ${data_dir}/initramfs/etc .
do_exec cp ${data_dir}/initramfs/init .

do_exec chmod 755 init
do_exec mknod dev/console c 5 1
do_exec mknod dev/null c 1 3
do_exec mknod dev/tty1 c 4 1

do_exec cp -a /lib/modules/\${kernel_module_src} lib/modules/

[ -f /boot/${arch}-initramfs_data.cpio.${init_compression} ] \
    && do_exec rm /boot/${arch}-initramfs_data.cpio.${init_compression}
find | cpio --quiet -o -H newc | ${init_compression} -9 \
    >/boot/${arch}-initramfs_data.cpio.${init_compression}
}

# This function handles the custom kernel options with --coprocessor
# argument (>=bash-4.0 Only)
do_coprocessor() {
# Detect non x86_64 processors with --co-processor=x86_64
[[ \$1 = x86_64 && ${procs[${cpu}]} =~ ^(M[4-6]86|MPENTIUMM|MK[6-7])$ \
    ]] && { ewarn "${procs[${cpu}]} invalid for x86_64 arch"; return 1; }

# We only patch what is needed here and we skip i{5,6}86 arches
[[ ${procs[${cpu}]} =~ ^M(PENTIUM(4|M|II|III)|CORE2|ATOM|K[6-8])$ ]] \
    && patch -p0 <${kernel_sources}-${procs[${cpu}]}.patch
}

prepare_kernel_opts() {
( cd ${data_dir}/kernel/\${1} || error "Could not switch to kernel \
    source directory"

    case ${arch} in
        i[4,5,6]86)
            if [[ ${procs[${cpu}]} != M486 || ${procs[${cpu}]} =~ \
                ^([3,5-6]86)$ ]]; then
                sed -e 's/CONFIG_M486=y/# CONFIG_M486 is not set/' \
                    -e "s/# CONFIG_${procs[${cpu}]} is not set/\
                    CONFIG_${procs[${cpu}]}=y/" ${kernel_sources} \
                    >.config-custom
            fi

            [[ ${arch} = i586 || ${procs[${cpu}]} = M586 ]] && \
                patch -p0 <${kernel_sources}-${procs[${cpu}]}.patch
            [[ ${arch} = i686 || ${procs[${cpu}]} = M686 ]] && \
                patch -p0 <${kernel_sources}-${procs[${cpu}]}.patch
            do_coprocessor ${arch}
            ;;
        x86_64)
            if [[ ${procs[${cpu}]} != GENERIC_CPU ]]; then                                                                
                sed -e 's/CONFIG_GENERIC_CPU=y/# CONFIG_GENERIC_CPU \
                    is not set/' -e "s/# CONFIG_${procs[${cpu}]} is \
                    not set/CONFIG_${procs[${cpu}]}=y/" \
                    ${kernel_sources} >.config-custom
            fi
            do_coprocessor ${arch}
    esac                                                                   
 
    if [[ ${procs[${cpu}]} =~ ^(M486|GENERIC_CPU)$ ]]; then
        do_exec cp ${kernel_sources} /usr/src/linux/.config
    else
        do_exec cp .config-custom /usr/src/linux/.config
    fi
)
}

do_kernel_compile() {
if ! grep "sys-kernel/${kernel_sources} symlink" \
    /etc/portage/package.use 1>/dev/null; then
    echo "sys-kernel/${kernel_sources} symlink">>/etc/portage/\
        package.use
fi

# Removed due to zen-overlay no longer in layman and zen-sources in tree
if [[ ! \$(ls -d /var/db/pkg/app-portage/layman-[0-9]* &>/dev/null) \
    && ${kernel_sources} = zen-sources ]]; then
    einfo "Compiling \${blue}layman\${nocolor}"

    do_exec emerge layman 1>/dev/null
    do_exec layman -Sa zen-overlay 1>/dev/null && echo "source \
        /usr/local/portage/layman/make.conf">>/etc/make.conf
elif [[ ${kernel_sources} = zen-sources ]]; then
    do_exec emerge ${kernel_sources} 1>/dev/null
else
    do_exec ${pms} ${kernel_sources} 1>/dev/null
fi
}

# JustBOOT kernel compilation and customization options
prepare_kernel() {
local date=$(date +%Y%m%d-%H%m)

if ${purge_kernel}; then
    ewarn "--purge-kernel used, removing sources..."
    do_exec unlink /usr/src/linux
    do_exec rm -rf /usr/src/* /lib/modules/*
fi

# Convert x86 arch for proper usage in kernel
case ${arch} in i[4,5,6]86) local arch=x86;; esac

if [[ ! -h /usr/src/linux || ! \$(ls -d /var/db/pkg/sys-kernel/\
    ${kernel_sources}-[0-9]* 2>/dev/null) ]]; then
    einfo "Compiling \${blue}${kernel_sources}\${nocolor}."
    do_kernel_compile

    einfo "Compiling \${blue}\${arch}\${nocolor} kernel image"
    if declare -A &>/dev/null; then
      do_exec prepare_kernel_opts \${arch}
    else 
      do_exec cp ${data_dir}/kernel/\${arch}/${kernel_sources} \
        /usr/src/linux/.config
    fi

    do_exec cd /usr/src/linux || error "Failed to switch to \
        kernel source directory"

    if ${menuconfig}; then
      do_exec make menuconfig
      do_exec make ${MAKEOPTS} 1>/dev/null
    else
      do_exec make ${MAKEOPTS} 1>/dev/null
    fi

    do_exec make modules_install 1>/dev/null
    einfo "\${red}\${arch}\${nocolor} kernel compiled, preparing \
        initramfs image."
    do_exec prepare_initramfs
  else
    if [ -f /usr/src/linux/.config ]; then
      einfo "Backing up old kernel config to \${red}/usr/src/linux/\
        .config.\${date}\${nocolor}"
      do_exec cp /usr/src/linux/.config /usr/src/linux/.config.\
        ${kernel_sources}-\${date}
    fi

    einfo "Compiling \${red}\${arch}\${nocolor} kernel image"
    do_kernel_compile

    if declare -A &>/dev/null; then
      do_exec prepare_kernel_opts \${arch}
    else
      do_exec cp ${data_dir}/kernel/\${arch}/${kernel_sources} \
        /usr/src/linux/.config
    fi
    do_exec cd /usr/src/linux || error "Failed to switch to \
        kernel source directory"

    if ${menuconfig}; then
      do_exec make menuconfig
      do_exec make ${MAKEOPTS} 1>/dev/null
    else
      do_exec make ${MAKEOPTS} 1>/dev/null
    fi

    do_exec make modules_install 1>/dev/null
    einfo "\${red}\${arch}\${nocolor} kernel compiled, preparing \
        initramfs image"
    do_exec prepare_initramfs
  fi

  do_exec cd /usr/src/linux || error "Failed to switch to \
    kernel source directory"
  do_exec cp arch/\${arch}/boot/bzImage /boot/vmlinuz
  do_exec update-modules

  einfo "Compiling \${blue}lvm2\${nocolor}"
  do_exec ${pms} lvm2 1>/dev/null

  einfo "Done with \${red}\${arch}\${nocolor} kernel"
  if ${letmein}; then
    einfo "letmein flag used. Type \${red}exit\${nocolor} when \
        finished to continue with build."
    exec /bin/bash -i
  fi
}

prepare_useropts() {
einfo "Setting root password to \"\${red}${root_passwd}\"\${nocolor}"

# Set the livecd root password according to --root-passwd otherwise use
# "gentoo" for root

echo "root:${root_passwd}" | chpasswd 1>/dev/null # BUG #275555
einfo "Root passwd set to \${red}\"${root_passwd}\"\${nocolor}"
}

diff () {
    printf '%s' \$(( \$(date -u -d"\$target" +%s) - \
        \$(date -u -d"\$current" +%s)))
}

check_toolchain_days() {
if [[ ${arch} = i586 && ! -f /etc/toolchain_age ]]; then
    ewarn "i586 needs a toolchain build, setting --force-toolchain flag"
    yes_tool=true
fi

if ${no_tool}; then
    ewarn "Skipping toolchain build"
    return 1
    elif ${yes_tool}; then
        ewarn "Forcing a toolchain build"
        date -u -d '2 days' '+%F %T.%N %Z'>/etc/toolchain_age
        return 0
    else

    [ ! -f /etc/toolchain_age ] && date -u -d 'now' '+%F %T.%N %Z'>\
        /etc/toolchain_age

    local current=\$(date -u -d 'now' '+%F %T.%N %Z')
    local target=\$(</etc/toolchain_age)
    local mphr=60 hpd=24 limit=60

    # current = now, target = Last time the toolchain was rebuild.  %F =
    # full date, %T = %H:%M:%S, %N = nanoseconds, %Z = time zone.  mphr
    # = Minutes per hour, hpd = Hours per day, limit = Days before a
    # toolchain rebuild.

    days=\$(( \$(diff) / \$mphr / \$mphr / \$hpd ))
    current=\$(date -d"\$current +\$days days" '+%F %T.%N %Z')
    toolchain_days=\$(printf '%s' "\$days")
    days_left=\$((limit-toolchain_days))

    if ((toolchain_days>limit)); then
        ewarn "Your toolchain is \${toolchain_days} days old passed the \
            \${limit} days limit."
        date -u -d '1 day' '+%F %T.%N %Z'>/etc/toolchain_age
        einfo "Preparing to rebuild the toolchain."
        return 0
    elif ((toolchain_days==0)); then
        # First day of toolchain build, increment by 1 day
        date -u -d '2 days' '+%F %T.%N %Z'>/etc/toolchain_age
        ewarn "You have \${days_left:-60} days left until your next \
            schedule bootstrap."
        einfo "Preparing to build the toolchain."
        return 0
    else
        ewarn "You have \${days_left:-60} days left until your next \
            schedule bootstrap"
        return 1
    fi
fi
}

bootstrap() {
# Enable livecd and user locales (see @confdir@/locale.gen)
if grep '#en_US ISO-8859-1' /etc/locale.gen &>/dev/null; then
    einfo "Setting locales"
    for i in ${locales[@]} "#en_US ISO-8859-1"; do
        sed -i "s/#\${i}/\${i}/" /etc/locale.gen
    done
fi

do_exec locale-gen 1>/dev/null

einfo "Setting localtime"
[ -e /etc/localtime ] && do_exec rm /etc/localtime
do_exec cp -a /usr/share/zoneinfo/UTC /etc/localtime

einfo "Updating portage tree"
do_exec emerge --sync -q 1>/dev/null

if ! ${no_tool}; then
    einfo "Compiling the toolchain, this maybe take a while depending \
        on hardware."
    for i in portage gcc-config binutils linux-headers glibc gcc; do
        einfo "Compiling \${blue}\${i}.\${nocolor}"
        do_exec ${pms} -1 \${i} 1>/dev/null && einfo "\${blue}\${i}\
            \${nocolor} compiled."
    done
    do_exec gcc-config 1 1>/dev/null && do_exec env-update 1>/dev/null \
        && do_exec source /etc/profile

    ! grep "\-\-hash\-style" /etc/make.conf &>/dev/null && sed -i \
        's/-Wl,/-Wl,--hash-style=gnu,/' /etc/make.conf

    for i in binutils linux-headers glibc gcc; do
        einfo "Compiling \${blue}\${i}.\${nocolor}"
        do_exec ${pms} -1 \${i} 1>/dev/null && einfo "\${blue}\${i}\
            \${nocolor} compiled."
    done
    einfo "Toolchain build finished, compiling system packages"

    while read ebuild; do
        einfo "Compiling \${blue}\"\${ebuild}\"\${nocolor}"
        do_exec ${pms} -1 "\${ebuild}" 1>/dev/null || \
            echo "\${ebuild}" >>failed
        einfo "\${blue}\"\${ebuild}\"\${nocolor} compiled"
        [[ \${ebuild} = dev-lang/python && "${pms}" = pmerge ]] && \
            python-updater &>/dev/null
    done < <(emerge -ep --columns --color=n system | grep ebuild | \
        awk '{print\$4}' | egrep -v "(glibc|/portage|binutils|gcc|linux-h)")

    while read ebuild; do
        einfo "Compiling \${blue}\"\${ebuild}\"\${nocolor}"
        do_exec ${pms} -1 "\${ebuild}" 1>/dev/null
        einfo "\${blue}\"\${ebuild}\"\${nocolor} compiled"
    done <failed
    do_exec rm failed

    einfo "Toolchain build completed"
else
    einfo "Toolchain built skipped"
fi
}

# Script to build busybox binary inside uclibc environment
cat >> \${uclibc_script} << BUSYBOX
#!/bin/bash
env-update 1>/dev/null && source /etc/profile

echo "Compiling Busybox"
cd \${busybox} && make -s
[ ! -f busybox.links ] && make busybox.links

echo "Busybox has been compiled"
exit
BUSYBOX
do_exec prepare_configs
do_exec check_deps
do_exec check_toolchain_days && do_exec bootstrap
do_exec prepare_packages
do_exec prepare_bootloader
do_exec prepare_busybox
do_exec prepare_kernel
do_exec prepare_useropts
CHROOT

# Lets go already!
[[ ! -d ${livedir} ]] && exec_chkdir ${livedir}
do_exec cd ${livedir} || error "Failed to switch to livecd build \
    directory! Exiting."
do_exec check_deps && do_exec prepare_stage

# vim: set et sts=4 sw=4 ts=4 tw=80:
